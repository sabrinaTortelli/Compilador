/* Generated By:JavaCC: Do not edit this line. LParser.java */
package br.univali.compiladores.compilador.model.parser;
import br.univali.compiladores.compilador.model.Compile.Compile;
import br.univali.compiladores.compilador.model.recovery.First;
import br.univali.compiladores.compilador.model.recovery.RecoverySet;
import br.univali.compiladores.compilador.model.recovery.ParseEOFException;
import br.univali.compiladores.compilador.view.WindowER;

public class LParser implements LParserConstants {
    private Compile compile;
    private int lexErrorCount;
    private int synErrorCount;

    //para o AS
    private boolean debug_recovery = true;
    private boolean eof; // indica se encontramos o end of file
    private Token lastError = null;

    static public String im(int x)
    {
        int k;
        String s;
            s = tokenImage[x];
            k = s.lastIndexOf("\"");
            try{
                s =s.substring(1,k);
            }catch (StringIndexOutOfBoundsException e){
                System.err.println(e.getMessage());
            }
            return s;
    }

    void consumeUntil(RecoverySet g,ParseException e, String met) throws ParseEOFException, ParseException
    {
        Token tok;
        System.out.println("reading " + met);
        if (debug_recovery)
        {
            System.out.println();
            System.out.println("*** " + met + " ***");
            System.out.println("    Synchronizing Set: " + g);
        }
        if (g == null) throw e;
        tok = getToken(1);
        while (!eof)
        {
            if(g.contains(tok.kind))
                {
                    if(debug_recovery) System.out.println("    Found synchronizing token: " + im(tok.kind));
                    break;
                }
            if(debug_recovery)
                System.out.println("    Ignoring token: " + im(tok.kind));
            getNextToken();
            tok = getToken(1);
            if (tok.kind == EOF && ! g.contains(EOF))
                eof = true;
        }
        if(tok != lastError)
        {
         System.out.println(e.getMessage());
         synErrorCount++;
         lastError = tok;
        }


        //System.out.println(e.getMessage());
        //synErrorCount++;
        if (eof) throw  new ParseEOFException("EOF found prematurely");
    }


    public int getLexErrorCount() {
        return lexErrorCount;
    }

    public int getSynErrorCount() {
        return synErrorCount;
    }


    public void setLexicalAnalysis(WindowER gui){
        compile = new Compile(gui);
    }

  final public void parseSyntactical() throws ParseException, ParseEOFException {
    trace_call("parseSyntactical");
    try {
      readProgram();
    } finally {
      trace_return("parseSyntactical");
    }
  }

  final public void readProgram() throws ParseException, ParseEOFException {
    trace_call("readProgram");
    try {
RecoverySet g = new RecoverySet(EOF);
      Program(g);
      jj_consume_token(0);
    } finally {
      trace_return("readProgram");
    }
  }

  final public void Program(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("Program");
    try {
RecoverySet f1 = new RecoverySet(ESP_SYMBOL_R_BRACKET).union(g),
            f2 = new RecoverySet(RESERVED_WORD_BODY).union(f1),
            f3 = First.DeclarationConstantsAndVariables.union(f2);
      try {
        jj_consume_token(RESERVED_WORD_DO);
        jj_consume_token(RESERVED_WORD_THIS);
        jj_consume_token(IDENTIFIER);
        jj_consume_token(ESP_SYMBOL_L_BRACKET);
        jj_consume_token(ESP_SYMBOL_R_BRACKET);
        DeclarationEnumeratedType(f3);
        DeclarationConstantsAndVariables(f2);
        jj_consume_token(RESERVED_WORD_BODY);
        jj_consume_token(ESP_SYMBOL_L_BRACKET);
        CommandList(f1);
        jj_consume_token(ESP_SYMBOL_R_BRACKET);
        Description(g);
        jj_consume_token(0);
      } catch (ParseException e) {
    compile.printNotRecognized(e, "declaração do programa");
    consumeUntil(g, e, "program declaration");
      }
    } finally {
      trace_return("Program");
    }
  }

//REVER MENSAGENS PARA O CONSUME UNTILL A PARTIR DAQUI
//bloco description
  final public void Description(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("Description");
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case RESERVED_WORD_DESCRIPTION:
          jj_consume_token(RESERVED_WORD_DESCRIPTION);
          jj_consume_token(CONST_LITERAL);
          break;
        default:
          jj_la1[0] = jj_gen;
          ;
        }
      } catch (ParseException e) {
        compile.printNotRecognized(e, "declaração da descrição");
        consumeUntil(g, e, "description statement");
      }
    } finally {
      trace_return("Description");
    }
  }

//DeclarationEnumeratedType block
  final public void DeclarationEnumeratedType(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("DeclarationEnumeratedType");
    try {
 RecoverySet f1 = new RecoverySet(ESP_SYMBOL_R_BRACKET);
      try {
        if (jj_2_1(2)) {
          jj_consume_token(RESERVED_WORD_DECLARATION);
          jj_consume_token(RESERVED_WORD_TYPE);
          jj_consume_token(ESP_SYMBOL_L_BRACKET);
          IdentifierEnumTypeDeclarationList(f1);
          jj_consume_token(ESP_SYMBOL_R_BRACKET);
        } else {
          ;
        }
      } catch (ParseException e) {
        compile.printNotRecognized(e, "declaração de tipo enumerado");
        consumeUntil(g, e, "enumerated type declaration");
      }
    } finally {
      trace_return("DeclarationEnumeratedType");
    }
  }

  final public void IdentifierEnumTypeDeclarationList(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("IdentifierEnumTypeDeclarationList");
    try {
RecoverySet f1 = new RecoverySet(ESP_SYMBOL_DOT);
      try {
        label_1:
        while (true) {
          jj_consume_token(IDENTIFIER);
          jj_consume_token(RESERVED_WORD_IS);
          IdentifierList(f1);
          jj_consume_token(ESP_SYMBOL_DOT);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENTIFIER:
            ;
            break;
          default:
            jj_la1[1] = jj_gen;
            break label_1;
          }
        }
      } catch (ParseException e) {
        compile.printNotRecognized(e, "declaração de lista de identificador de tipo enumerado");
        consumeUntil(g, e, "Identifier Enum Type Declaration List");
      }
    } finally {
      trace_return("IdentifierEnumTypeDeclarationList");
    }
  }

  final public void IdentifierList(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("IdentifierList");
    try {
      try {
        jj_consume_token(IDENTIFIER);
        label_2:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ESP_SYMBOL_COMA:
            ;
            break;
          default:
            jj_la1[2] = jj_gen;
            break label_2;
          }
          jj_consume_token(ESP_SYMBOL_COMA);
          jj_consume_token(IDENTIFIER);
        }
      } catch (ParseException e) {
        compile.printNotRecognized(e, "lista de identificadores");
        consumeUntil(g, e, "identifier list");
      }
    } finally {
      trace_return("IdentifierList");
    }
  }

  final public void DeclarationConstantsAndVariables(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("DeclarationConstantsAndVariables");
    try {
 RecoverySet f1 = new RecoverySet(ESP_SYMBOL_R_BRACKET);
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case RESERVED_WORD_DECLARATION:
          jj_consume_token(RESERVED_WORD_DECLARATION);
          jj_consume_token(RESERVED_WORD_CONSTANT);
          jj_consume_token(RESERVED_WORD_AND);
          jj_consume_token(RESERVED_WORD_VARIABLE);
          jj_consume_token(ESP_SYMBOL_L_BRACKET);
          OrderConstantsAndVariables(f1);
          jj_consume_token(ESP_SYMBOL_R_BRACKET);
          break;
        default:
          jj_la1[3] = jj_gen;
          ;
        }
      } catch (ParseException e) {
          compile.printNotRecognized(e, "declaração de constantes e variáveis");
        consumeUntil(g, e, "declaration constants and varibles");
      }
    } finally {
      trace_return("DeclarationConstantsAndVariables");
    }
  }

  final public void OrderConstantsAndVariables(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("OrderConstantsAndVariables");
    try {
      try {
        jj_consume_token(RESERVED_WORD_AS);
        ConstantAndVariablesInitiation(g);
      } catch (ParseException e) {
          compile.printNotRecognized(e, "ordenação de constantes e variáveis");
        consumeUntil(g, e, "order constant and variables");
      }
    } finally {
      trace_return("OrderConstantsAndVariables");
    }
  }

  final public void ConstantAndVariablesInitiation(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("ConstantAndVariablesInitiation");
    try {
 RecoverySet f1 = First.AsVariables.union(g),
             f2 = First.AsConstants.union(g);
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case RESERVED_WORD_CONSTANT:
          jj_consume_token(RESERVED_WORD_CONSTANT);
          AsConstants(f1);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case RESERVED_WORD_AS:
            jj_consume_token(RESERVED_WORD_AS);
            jj_consume_token(RESERVED_WORD_VARIABLE);
            AsVariables(g);
            break;
          default:
            jj_la1[4] = jj_gen;
            ;
          }
          break;
        case RESERVED_WORD_VARIABLE:
          jj_consume_token(RESERVED_WORD_VARIABLE);
          AsVariables(f2);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case RESERVED_WORD_AS:
            jj_consume_token(RESERVED_WORD_AS);
            jj_consume_token(RESERVED_WORD_CONSTANT);
            AsConstants(g);
            break;
          default:
            jj_la1[5] = jj_gen;
            ;
          }
          break;
        default:
          jj_la1[6] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException e) {
        compile.printNotRecognized(e, "inicialização de constantes e variáveis");
        consumeUntil(g, e, "constants and varibles");
      }
    } finally {
      trace_return("ConstantAndVariablesInitiation");
    }
  }

// Constants Declaration sub block
  final public void AsConstants(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("AsConstants");
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          ConstantsList(g);
          break;
        default:
          jj_la1[7] = jj_gen;
          ;
        }
      } catch (ParseException e) {
            compile.printNotRecognized(e, "constantes");
            consumeUntil(g, e, "Constants");
      }
    } finally {
      trace_return("AsConstants");
    }
  }

  final public void ConstantsList(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("ConstantsList");
    try {
 RecoverySet f1 = new RecoverySet(RESERVED_WORD_IS),
             f2 = new RecoverySet(ESP_SYMBOL_DOT);
      try {
        label_3:
        while (true) {
          IdentifierList(f1);
          jj_consume_token(RESERVED_WORD_IS);
          ConstTypeValueCombo(f2);
          jj_consume_token(ESP_SYMBOL_DOT);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENTIFIER:
            ;
            break;
          default:
            jj_la1[8] = jj_gen;
            break label_3;
          }
        }
      } catch (ParseException e) {
            compile.printNotRecognized(e, "lista de constantes");
            consumeUntil(g, e, "constants list");
      }
    } finally {
      trace_return("ConstantsList");
    }
  }

  final public void ConstTypeValueCombo(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("ConstTypeValueCombo");
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case RESERVED_WORD_INTEGER:
          jj_consume_token(RESERVED_WORD_INTEGER);
          jj_consume_token(ESP_SYMBOL_ASSIGNE);
          jj_consume_token(CONST_INT);
          break;
        case RESERVED_WORD_REAL:
          jj_consume_token(RESERVED_WORD_REAL);
          jj_consume_token(ESP_SYMBOL_ASSIGNE);
          jj_consume_token(CONST_REAL);
          break;
        case RESERVED_WORD_STRING:
          jj_consume_token(RESERVED_WORD_STRING);
          jj_consume_token(ESP_SYMBOL_ASSIGNE);
          jj_consume_token(CONST_LITERAL);
          break;
        case RESERVED_WORD_LOGIC:
          jj_consume_token(RESERVED_WORD_LOGIC);
          jj_consume_token(ESP_SYMBOL_ASSIGNE);
          TypeAndValueLogicConstants(g);
          break;
        default:
          jj_la1[9] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException e) {
        compile.printNotRecognized(e, "tipo e valor de constantes");
        consumeUntil(g, e, "type constants");
      }
    } finally {
      trace_return("ConstTypeValueCombo");
    }
  }

  final public void TypeAndValueLogicConstants(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("TypeAndValueLogicConstants");
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case RESERVED_WORD_TRUE:
          jj_consume_token(RESERVED_WORD_TRUE);
          break;
        case RESERVED_WORD_UNTRUE:
          jj_consume_token(RESERVED_WORD_UNTRUE);
          break;
        default:
          jj_la1[10] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException e) {
        compile.printNotRecognized(e, "tipo e valor de constantes lógicas");
        consumeUntil(g, e, "logical operators");
      }
    } finally {
      trace_return("TypeAndValueLogicConstants");
    }
  }

//Variables declaration sub block
  final public void AsVariables(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("AsVariables");
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          VariablesList(g);
          break;
        default:
          jj_la1[11] = jj_gen;
          ;
        }
      } catch (ParseException e) {
        compile.printNotRecognized(e, "variáveis");
        consumeUntil(g, e, "Varibles");
      }
    } finally {
      trace_return("AsVariables");
    }
  }

  final public void VariablesList(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("VariablesList");
    try {
  RecoverySet f1 = new RecoverySet(RESERVED_WORD_IS),
              f2 = new RecoverySet(ESP_SYMBOL_DOT);
      try {
        label_4:
        while (true) {
          IdentifierVariablesList(f1);
          jj_consume_token(RESERVED_WORD_IS);
          VariablesTypes(f2);
          jj_consume_token(ESP_SYMBOL_DOT);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENTIFIER:
            ;
            break;
          default:
            jj_la1[12] = jj_gen;
            break label_4;
          }
        }
      } catch (ParseException e) {
     compile.printNotRecognized(e, "lista de variáveis");
 consumeUntil(g, e, "List Of Variable Identifiers");
      }
    } finally {
      trace_return("VariablesList");
    }
  }

  final public void IdentifierVariablesList(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("IdentifierVariablesList");
    try {
 RecoverySet f1 = First.Index.union(g);
      try {
        jj_consume_token(IDENTIFIER);
        Index(f1);
        label_5:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ESP_SYMBOL_COMA:
            ;
            break;
          default:
            jj_la1[13] = jj_gen;
            break label_5;
          }
          jj_consume_token(ESP_SYMBOL_COMA);
          jj_consume_token(IDENTIFIER);
          Index(f1);
        }
      } catch (ParseException e) {
     compile.printNotRecognized(e, "lista de identificadores de variáveis");
 consumeUntil(g, e, "Identifier Variables List");
      }
    } finally {
      trace_return("IdentifierVariablesList");
    }
  }

  final public void Index(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("Index");
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ESP_SYMBOL_L_BRACE:
          jj_consume_token(ESP_SYMBOL_L_BRACE);
          jj_consume_token(CONST_INT);
          jj_consume_token(ESP_SYMBOL_R_BRACE);
          break;
        default:
          jj_la1[14] = jj_gen;
          ;
        }
      } catch (ParseException e) {
        compile.printNotRecognized(e, "índice");
        consumeUntil(g, e, "index");
      }
    } finally {
      trace_return("Index");
    }
  }

  final public void VariablesTypes(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("VariablesTypes");
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case RESERVED_WORD_INTEGER:
          jj_consume_token(RESERVED_WORD_INTEGER);
          break;
        case RESERVED_WORD_REAL:
          jj_consume_token(RESERVED_WORD_REAL);
          break;
        case RESERVED_WORD_STRING:
          jj_consume_token(RESERVED_WORD_STRING);
          break;
        case RESERVED_WORD_LOGIC:
          jj_consume_token(RESERVED_WORD_LOGIC);
          break;
        default:
          jj_la1[15] = jj_gen;
          DeclarationEnumeratedType(g);
        }
      } catch (ParseException e) {
        compile.printNotRecognized(e, "tipos de variáveis");
        consumeUntil(g, e, "Variables Types");
      }
    } finally {
      trace_return("VariablesTypes");
    }
  }

//====================================================================================
//Assignmeent block
  final public void CmdAssignment(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("CmdAssignment");
    try {
 RecoverySet f1 = new RecoverySet(RESERVED_WORD_AS),
             f2 = new RecoverySet(ESP_SYMBOL_DOT);
      try {
        jj_consume_token(RESERVED_WORD_DESIGNATE);
        jj_consume_token(RESERVED_WORD_THIS);
        IdentifierVariablesList(f1);
        jj_consume_token(RESERVED_WORD_AS);
        Expression(f2);
        jj_consume_token(ESP_SYMBOL_DOT);
      } catch (ParseException e) {
        compile.printNotRecognized(e, "declaração de comando de atribuição");
        consumeUntil(g, e, "Command Assignment declaration");
      }
    } finally {
      trace_return("CmdAssignment");
    }
  }

  final public void Expression(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("Expression");
    try {
RecoverySet f1 = First.ExpressionL.union(g);
      try {
        ArithmeticOrLogicalExpression(f1);
        ExpressionL(g);
      } catch (ParseException e) {
          compile.printNotRecognized(e, "expressão");
          consumeUntil(g, e, "expression");
      }
    } finally {
      trace_return("Expression");
    }
  }

  final public void ExpressionL(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("ExpressionL");
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ESP_SYMBOL_EQUAL:
        case ESP_SYMBOL_DIFFERENT:
        case ESP_SYMBOL_GREATER:
        case ESP_SYMBOL_LESSER:
        case ESP_SYMBOL_GREATEREQUAL:
        case ESP_SYMBOL_LESSERREQUAL:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ESP_SYMBOL_EQUAL:
            jj_consume_token(ESP_SYMBOL_EQUAL);
            ArithmeticOrLogicalExpression(g);
            break;
          case ESP_SYMBOL_DIFFERENT:
            jj_consume_token(ESP_SYMBOL_DIFFERENT);
            ArithmeticOrLogicalExpression(g);
            break;
          case ESP_SYMBOL_GREATER:
            jj_consume_token(ESP_SYMBOL_GREATER);
            ArithmeticOrLogicalExpression(g);
            break;
          case ESP_SYMBOL_LESSER:
            jj_consume_token(ESP_SYMBOL_LESSER);
            ArithmeticOrLogicalExpression(g);
            break;
          case ESP_SYMBOL_LESSERREQUAL:
            jj_consume_token(ESP_SYMBOL_LESSERREQUAL);
            ArithmeticOrLogicalExpression(g);
            break;
          case ESP_SYMBOL_GREATEREQUAL:
            jj_consume_token(ESP_SYMBOL_GREATEREQUAL);
            ArithmeticOrLogicalExpression(g);
            break;
          default:
            jj_la1[16] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[17] = jj_gen;
          ;
        }
      } catch (ParseException e) {
        compile.printNotRecognized(e, "comparação de operadores");
        consumeUntil(g, e, "comparative operators");
      }
    } finally {
      trace_return("ExpressionL");
    }
  }

  final public void ArithmeticOrLogicalExpression(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("ArithmeticOrLogicalExpression");
    try {
RecoverySet f1 = First.LowestPriority.union(g);
      try {
        SecondTerm(f1);
        LowestPriority(g);
      } catch (ParseException e) {
    compile.printNotRecognized(e, "expressão aritmética ou lógica");
consumeUntil(g, e, "arithmetical or logical expression");
      }
    } finally {
      trace_return("ArithmeticOrLogicalExpression");
    }
  }

  final public void LowestPriority(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("LowestPriority");
    try {
 RecoverySet f1 = First.LowestPriority.union(g);
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ESP_SYMBOL_PLUS:
        case ESP_SYMBOL_MINUS:
        case ESP_SYMBOL_OR:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ESP_SYMBOL_PLUS:
            jj_consume_token(ESP_SYMBOL_PLUS);
            SecondTerm(f1);
            LowestPriority(g);
            break;
          case ESP_SYMBOL_MINUS:
            jj_consume_token(ESP_SYMBOL_MINUS);
            SecondTerm(f1);
            LowestPriority(g);
            break;
          case ESP_SYMBOL_OR:
            jj_consume_token(ESP_SYMBOL_OR);
            SecondTerm(f1);
            LowestPriority(g);
            break;
          default:
            jj_la1[18] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[19] = jj_gen;
          ;
        }
      } catch (ParseException e) {
    compile.printNotRecognized(e, "menor prioridade de expressões");
    consumeUntil(g, e, "low priority expression values");
      }
    } finally {
      trace_return("LowestPriority");
    }
  }

  final public void SecondTerm(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("SecondTerm");
    try {
 RecoverySet f1 = First.MediumPriority.union(g);
      try {
        FirstTerm(f1);
        MediumPriority(g);
      } catch (ParseException e) {
    compile.printNotRecognized(e, "segundo termo de expressões");
    consumeUntil(g, e, "expression second term");
      }
    } finally {
      trace_return("SecondTerm");
    }
  }

  final public void MediumPriority(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("MediumPriority");
    try {
 RecoverySet f1 = First.MediumPriority.union(g);
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ESP_SYMBOL_STAR:
        case ESP_SYMBOL_DIVISION_REAL:
        case ESP_SYMBOL_DIVISION_INT:
        case ESP_SYMBOL_MOD:
        case ESP_SYMBOL_AND:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ESP_SYMBOL_STAR:
            jj_consume_token(ESP_SYMBOL_STAR);
            FirstTerm(f1);
            MediumPriority(g);
            break;
          case ESP_SYMBOL_DIVISION_REAL:
            jj_consume_token(ESP_SYMBOL_DIVISION_REAL);
            FirstTerm(f1);
            MediumPriority(g);
            break;
          case ESP_SYMBOL_DIVISION_INT:
            jj_consume_token(ESP_SYMBOL_DIVISION_INT);
            FirstTerm(f1);
            MediumPriority(g);
            break;
          case ESP_SYMBOL_MOD:
            jj_consume_token(ESP_SYMBOL_MOD);
            FirstTerm(f1);
            MediumPriority(g);
            break;
          case ESP_SYMBOL_AND:
            jj_consume_token(ESP_SYMBOL_AND);
            FirstTerm(f1);
            MediumPriority(g);
            break;
          default:
            jj_la1[20] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[21] = jj_gen;
          ;
        }
      } catch (ParseException e) {
    compile.printNotRecognized(e, "média prioridade de expressões");
    consumeUntil(g, e, "medium priority expression values");
      }
    } finally {
      trace_return("MediumPriority");
    }
  }

  final public void FirstTerm(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("FirstTerm");
    try {
 RecoverySet f1 = First.HighestPriority.union(g);
      try {
        Element(f1);
        HighestPriority(g);
      } catch (ParseException e) {
        compile.printNotRecognized(e, "primeiro termo de expressões");
    consumeUntil(g, e, "expression first term");
      }
    } finally {
      trace_return("FirstTerm");
    }
  }

  final public void HighestPriority(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("HighestPriority");
    try {
 RecoverySet f1 = First.HighestPriority.union(g);
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ESP_SYMBOL_POWER:
          jj_consume_token(ESP_SYMBOL_POWER);
          Element(f1);
          HighestPriority(g);
          break;
        default:
          jj_la1[22] = jj_gen;
          ;
        }
      } catch (ParseException e) {
    compile.printNotRecognized(e, "alta prioridade de expressões");
    consumeUntil(g, e, "high priority expression values");
      }
    } finally {
      trace_return("HighestPriority");
    }
  }

  final public void Element(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("Element");
    try {
 RecoverySet f1 = new RecoverySet(ESP_SYMBOL_R_PARENTHESIS);
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          jj_consume_token(IDENTIFIER);
          Index(g);
          break;
        case CONST_INT:
          jj_consume_token(CONST_INT);
          break;
        case CONST_REAL:
          jj_consume_token(CONST_REAL);
          break;
        case CONST_LITERAL:
          jj_consume_token(CONST_LITERAL);
          break;
        case RESERVED_WORD_TRUE:
          jj_consume_token(RESERVED_WORD_TRUE);
          break;
        case RESERVED_WORD_UNTRUE:
          jj_consume_token(RESERVED_WORD_UNTRUE);
          break;
        case ESP_SYMBOL_L_PARENTHESIS:
          jj_consume_token(ESP_SYMBOL_L_PARENTHESIS);
          Expression(f1);
          jj_consume_token(ESP_SYMBOL_R_PARENTHESIS);
          break;
        case ESP_SYMBOL_DIFFERENT:
          jj_consume_token(ESP_SYMBOL_DIFFERENT);
          jj_consume_token(ESP_SYMBOL_L_PARENTHESIS);
          Expression(f1);
          jj_consume_token(ESP_SYMBOL_R_PARENTHESIS);
          break;
        default:
          jj_la1[23] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException e) {
    compile.printNotRecognized(e, "elemento");
    consumeUntil(g, e, "Element");
      }
    } finally {
      trace_return("Element");
    }
  }

//index is located at Variables declaration sub block/
//====================================================================================
//Data input block
  final public void CmdDataInput(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("CmdDataInput");
    try {
 RecoverySet f1 = new RecoverySet(ESP_SYMBOL_R_BRACKET);
      try {
        jj_consume_token(RESERVED_WORD_READ);
        jj_consume_token(RESERVED_WORD_THIS);
        jj_consume_token(ESP_SYMBOL_L_BRACKET);
        IdentifierVariablesList(f1);
        jj_consume_token(ESP_SYMBOL_R_BRACKET);
        jj_consume_token(ESP_SYMBOL_DOT);
      } catch (ParseException e) {
    compile.printNotRecognized(e, "declaração de comando de entrada de dados");
    consumeUntil(g, e, "Command Input Data Declaration");
      }
    } finally {
      trace_return("CmdDataInput");
    }
  }

//====================================================================================
//Data output block
  final public void CmdDataOutput(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("CmdDataOutput");
    try {
      try {
        jj_consume_token(RESERVED_WORD_WRITE);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case RESERVED_WORD_THIS:
          This(g);
          break;
        case RESERVED_WORD_ALL:
          AllThis(g);
          break;
        default:
          jj_la1[24] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException e) {
    compile.printNotRecognized(e, "declaração de comando de saída de dados");
    consumeUntil(g, e, "Command Output Data Declaration");
      }
    } finally {
      trace_return("CmdDataOutput");
    }
  }

  final public void This(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("This");
    try {
RecoverySet f1 = new RecoverySet(ESP_SYMBOL_R_BRACKET);
      try {
        jj_consume_token(RESERVED_WORD_THIS);
        jj_consume_token(ESP_SYMBOL_L_BRACKET);
        IdentifiersAndOrConstantsList(f1);
        jj_consume_token(ESP_SYMBOL_R_BRACKET);
        jj_consume_token(ESP_SYMBOL_DOT);
      } catch (ParseException e) {
    compile.printNotRecognized(e, "saída de dados this");
    consumeUntil(g, e, "output this");
      }
    } finally {
      trace_return("This");
    }
  }

  final public void AllThis(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("AllThis");
    try {
      try {
        jj_consume_token(RESERVED_WORD_ALL);
        This(g);
      } catch (ParseException e) {
    compile.printNotRecognized(e, "saída de dados all this");
    consumeUntil(g, e, "output all this");
      }
    } finally {
      trace_return("AllThis");
    }
  }

  final public void IdentifiersAndOrConstantsList(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("IdentifiersAndOrConstantsList");
    try {
 RecoverySet f1 = First.OutPutConstants.union(g);
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          if (jj_2_2(3)) {
            IdentifierVariablesList(g);
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case IDENTIFIER:
              IdentifierList(g);
              break;
            default:
              jj_la1[25] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          break;
        case CONST_INT:
        case CONST_REAL:
        case CONST_LITERAL:
          OutPutConstants(f1);
          label_6:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case ESP_SYMBOL_COMA:
              ;
              break;
            default:
              jj_la1[26] = jj_gen;
              break label_6;
            }
            jj_consume_token(ESP_SYMBOL_COMA);
            OutPutConstants(f1);
          }
          break;
        default:
          jj_la1[27] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException e) {
        compile.printNotRecognized(e, "lista de constantes e/ou identificadores");
    consumeUntil(g, e, "output");
      }
    } finally {
      trace_return("IdentifiersAndOrConstantsList");
    }
  }

  final public void OutPutConstants(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("OutPutConstants");
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CONST_LITERAL:
          jj_consume_token(CONST_LITERAL);
          break;
        case CONST_INT:
          jj_consume_token(CONST_INT);
          break;
        case CONST_REAL:
          jj_consume_token(CONST_REAL);
          break;
        default:
          jj_la1[28] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException e) {
    compile.printNotRecognized(e, "saída de dados de constantes");
    consumeUntil(g, e, "output");
      }
    } finally {
      trace_return("OutPutConstants");
    }
  }

//====================================================================================
//Selection command block
  final public void CmdSelection(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("CmdSelection");
    try {
RecoverySet f1 = new RecoverySet(ESP_SYMBOL_DOT),
            f2 = First.Evaluate.union(f1);
      try {
        jj_consume_token(RESERVED_WORD_AVALIATE);
        jj_consume_token(RESERVED_WORD_THIS);
        Expression(f2);
        Evaluate(f1);
        jj_consume_token(ESP_SYMBOL_DOT);
      } catch (ParseException e) {
    compile.printNotRecognized(e, "declaração de comando de seleção");
    consumeUntil(g, e, "Command Select Declaration");
      }
    } finally {
      trace_return("CmdSelection");
    }
  }

  final public void Evaluate(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("Evaluate");
    try {
 RecoverySet f1 = First.EvaluateUntrue.union(g),
                        f2 = First.EvaluateTrue.union(g);
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case RESERVED_WORD_TRUE:
          EvaluateTrue(f1);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case RESERVED_WORD_UNTRUE:
            EvaluateUntrue(g);
            break;
          default:
            jj_la1[29] = jj_gen;
            ;
          }
          break;
        case RESERVED_WORD_UNTRUE:
          EvaluateUntrue(f2);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case RESERVED_WORD_TRUE:
            EvaluateTrue(g);
            break;
          default:
            jj_la1[30] = jj_gen;
            ;
          }
          break;
        default:
          jj_la1[31] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException e) {
    compile.printNotRecognized(e, "avaliação");
    consumeUntil(g, e, "Evaluate");
      }
    } finally {
      trace_return("Evaluate");
    }
  }

  final public void EvaluateTrue(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("EvaluateTrue");
    try {
RecoverySet f1 = new RecoverySet(ESP_SYMBOL_R_BRACKET);
      try {
        jj_consume_token(RESERVED_WORD_TRUE);
        jj_consume_token(RESERVED_WORD_RESULT);
        jj_consume_token(ESP_SYMBOL_L_BRACKET);
        CommandList(f1);
        jj_consume_token(ESP_SYMBOL_R_BRACKET);
      } catch (ParseException e) {
    compile.printNotRecognized(e, "declaração da seleção: true");
    consumeUntil(g, e, "selection statement: true");
      }
    } finally {
      trace_return("EvaluateTrue");
    }
  }

  final public void EvaluateUntrue(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("EvaluateUntrue");
    try {
RecoverySet f1 = new RecoverySet(ESP_SYMBOL_R_BRACKET);
      try {
        jj_consume_token(RESERVED_WORD_UNTRUE);
        jj_consume_token(RESERVED_WORD_RESULT);
        jj_consume_token(ESP_SYMBOL_L_BRACKET);
        CommandList(f1);
        jj_consume_token(ESP_SYMBOL_R_BRACKET);
      } catch (ParseException e) {
        compile.printNotRecognized(e, "declaração da seleção: untrue");
    consumeUntil(g, e, "selection statement: untrue");
      }
    } finally {
      trace_return("EvaluateUntrue");
    }
  }

  final public void CommandList(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("CommandList");
    try {
 RecoverySet f1 = First.Command.union(g);
      try {
        label_7:
        while (true) {
          Command(f1);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case RESERVED_WORD_DESIGNATE:
          case RESERVED_WORD_READ:
          case RESERVED_WORD_WRITE:
          case RESERVED_WORD_REPEAT:
          case RESERVED_WORD_AVALIATE:
            ;
            break;
          default:
            jj_la1[32] = jj_gen;
            break label_7;
          }
        }
      } catch (ParseException e) {
    compile.printNotRecognized(e, "lista de comandos");
    consumeUntil(g, e, "command list");
      }
    } finally {
      trace_return("CommandList");
    }
  }

  final public void Command(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("Command");
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case RESERVED_WORD_DESIGNATE:
          CmdAssignment(g);
          break;
        case RESERVED_WORD_READ:
          CmdDataInput(g);
          break;
        case RESERVED_WORD_WRITE:
          CmdDataOutput(g);
          break;
        case RESERVED_WORD_AVALIATE:
          CmdSelection(g);
          break;
        case RESERVED_WORD_REPEAT:
          CmdRepetition(g);
          break;
        default:
          jj_la1[33] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException e) {
    compile.printNotRecognized(e, "declaração de comando");
    consumeUntil(g, e, "command");
      }
    } finally {
      trace_return("Command");
    }
  }

  final public void CmdRepetition(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("CmdRepetition");
    try {
RecoverySet f2 = new RecoverySet(ESP_SYMBOL_DOT);
RecoverySet f1 = First.EvaluateRep.union(f2);
      try {
        jj_consume_token(RESERVED_WORD_REPEAT);
        jj_consume_token(RESERVED_WORD_THIS);
        Expression(f1);
        EvaluateRep(f2);
        jj_consume_token(ESP_SYMBOL_DOT);
      } catch (ParseException e) {
        compile.printNotRecognized(e, "declaração de comando de repetição");
    consumeUntil(g, e, "Command Repetition Declaration");
      }
    } finally {
      trace_return("CmdRepetition");
    }
  }

  final public void EvaluateRep(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("EvaluateRep");
    try {
      try {
        if (jj_2_3(2)) {
          EvaluateRepTrue(g);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ESP_SYMBOL_L_BRACKET:
            EvaluateRepUntrue(g);
            break;
          default:
            jj_la1[34] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      } catch (ParseException e) {
    compile.printNotRecognized(e, "avaliação de condição de repetição");
    consumeUntil(g, e, "Evaluate Repetition Condition");
      }
    } finally {
      trace_return("EvaluateRep");
    }
  }

  final public void EvaluateRepTrue(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("EvaluateRepTrue");
    try {
RecoverySet f1 = new RecoverySet(ESP_SYMBOL_R_BRACKET);
      try {
        jj_consume_token(ESP_SYMBOL_L_BRACKET);
        CommandList(f1);
        jj_consume_token(ESP_SYMBOL_R_BRACKET);
      } catch (ParseException e) {
        compile.printNotRecognized(e, "avaliação de repetição: condição satisfeita");
    consumeUntil(g, e, "repetition evaluation: condition satisfied");
      }
    } finally {
      trace_return("EvaluateRepTrue");
    }
  }

  final public void EvaluateRepUntrue(RecoverySet g) throws ParseException, ParseEOFException {
    trace_call("EvaluateRepUntrue");
    try {
RecoverySet f1 = new RecoverySet(ESP_SYMBOL_R_BRACKET);
      try {
        jj_consume_token(ESP_SYMBOL_L_BRACKET);
        jj_consume_token(ESP_SYMBOL_R_BRACKET);
      } catch (ParseException e) {
        compile.printNotRecognized(e, "avaliação de repetição: condição não satisfeita");
    consumeUntil(g, e, "repetition evaluation: condition not satisfied");
      }
    } finally {
      trace_return("EvaluateRepUntrue");
    }
  }

  final public void parseLexical() throws ParseException {
    trace_call("parseLexical");
    try {
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ESP_SYMBOL_L_BRACKET:
        case ESP_SYMBOL_R_BRACKET:
        case ESP_SYMBOL_L_PARENTHESIS:
        case ESP_SYMBOL_R_PARENTHESIS:
        case ESP_SYMBOL_L_BRACE:
        case ESP_SYMBOL_R_BRACE:
        case ESP_SYMBOL_DOT:
        case ESP_SYMBOL_COMA:
        case ESP_SYMBOL_ASSIGNE:
        case ESP_SYMBOL_PLUS:
        case ESP_SYMBOL_MINUS:
        case ESP_SYMBOL_STAR:
        case ESP_SYMBOL_DIVISION_REAL:
        case ESP_SYMBOL_POWER:
        case ESP_SYMBOL_DIVISION_INT:
        case ESP_SYMBOL_MOD:
        case ESP_SYMBOL_EQUAL:
        case ESP_SYMBOL_DIFFERENT:
        case ESP_SYMBOL_GREATER:
        case ESP_SYMBOL_LESSER:
        case ESP_SYMBOL_GREATEREQUAL:
        case ESP_SYMBOL_LESSERREQUAL:
        case ESP_SYMBOL_AND:
        case ESP_SYMBOL_OR:
        case ESP_SYMBOL_NOT:
        case RESERVED_WORD_DO:
        case RESERVED_WORD_THIS:
        case RESERVED_WORD_BODY:
        case RESERVED_WORD_DESCRIPTION:
        case RESERVED_WORD_DECLARATION:
        case RESERVED_WORD_TYPE:
        case RESERVED_WORD_IS:
        case RESERVED_WORD_CONSTANT:
        case RESERVED_WORD_AND:
        case RESERVED_WORD_VARIABLE:
        case RESERVED_WORD_AS:
        case RESERVED_WORD_INTEGER:
        case RESERVED_WORD_REAL:
        case RESERVED_WORD_STRING:
        case RESERVED_WORD_LOGIC:
        case RESERVED_WORD_DESIGNATE:
        case RESERVED_WORD_READ:
        case RESERVED_WORD_WRITE:
        case RESERVED_WORD_ALL:
        case RESERVED_WORD_REPEAT:
        case RESERVED_WORD_AVALIATE:
        case RESERVED_WORD_RESULT:
        case RESERVED_WORD_TRUE:
        case RESERVED_WORD_UNTRUE:
        case CONST_INT:
        case CONST_REAL:
        case CONST_LITERAL:
        case IDENTIFIER:
        case NONSUPPORTED_SYMBOL:
        case NONSUPPORTED_CONST_LITERAL_SINGLE:
        case NONSUPPORTED_CONST_LITERAL_DOUBLE:
        case NONSUPPORTED_BLOCK_COMMENT:
        case NONSUPPORTED_IDENTIFIER:
          ;
          break;
        default:
          jj_la1[35] = jj_gen;
          break label_8;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NONSUPPORTED_BLOCK_COMMENT:
          nonsupportedBlockComment();
          break;
        case ESP_SYMBOL_L_BRACKET:
        case ESP_SYMBOL_R_BRACKET:
        case ESP_SYMBOL_L_PARENTHESIS:
        case ESP_SYMBOL_R_PARENTHESIS:
        case ESP_SYMBOL_L_BRACE:
        case ESP_SYMBOL_R_BRACE:
        case ESP_SYMBOL_DOT:
        case ESP_SYMBOL_COMA:
        case ESP_SYMBOL_ASSIGNE:
        case ESP_SYMBOL_PLUS:
        case ESP_SYMBOL_MINUS:
        case ESP_SYMBOL_STAR:
        case ESP_SYMBOL_DIVISION_REAL:
        case ESP_SYMBOL_POWER:
        case ESP_SYMBOL_DIVISION_INT:
        case ESP_SYMBOL_MOD:
        case ESP_SYMBOL_EQUAL:
        case ESP_SYMBOL_DIFFERENT:
        case ESP_SYMBOL_GREATER:
        case ESP_SYMBOL_LESSER:
        case ESP_SYMBOL_GREATEREQUAL:
        case ESP_SYMBOL_LESSERREQUAL:
        case ESP_SYMBOL_AND:
        case ESP_SYMBOL_OR:
        case ESP_SYMBOL_NOT:
          specialSymbol();
          break;
        case RESERVED_WORD_DO:
        case RESERVED_WORD_THIS:
        case RESERVED_WORD_BODY:
        case RESERVED_WORD_DESCRIPTION:
        case RESERVED_WORD_DECLARATION:
        case RESERVED_WORD_TYPE:
        case RESERVED_WORD_IS:
        case RESERVED_WORD_CONSTANT:
        case RESERVED_WORD_AND:
        case RESERVED_WORD_VARIABLE:
        case RESERVED_WORD_AS:
        case RESERVED_WORD_INTEGER:
        case RESERVED_WORD_REAL:
        case RESERVED_WORD_STRING:
        case RESERVED_WORD_LOGIC:
        case RESERVED_WORD_DESIGNATE:
        case RESERVED_WORD_READ:
        case RESERVED_WORD_WRITE:
        case RESERVED_WORD_ALL:
        case RESERVED_WORD_REPEAT:
        case RESERVED_WORD_AVALIATE:
        case RESERVED_WORD_RESULT:
        case RESERVED_WORD_TRUE:
        case RESERVED_WORD_UNTRUE:
          reservedWord();
          break;
        case CONST_INT:
          constInt();
          break;
        case CONST_REAL:
          constReal();
          break;
        case CONST_LITERAL:
          constLiteral();
          break;
        case IDENTIFIER:
          identifier();
          break;
        case NONSUPPORTED_SYMBOL:
          nonsupportedSymbol();
          break;
        case NONSUPPORTED_CONST_LITERAL_SINGLE:
          nonsupportedConstLiteralSingle();
          break;
        case NONSUPPORTED_CONST_LITERAL_DOUBLE:
          nonsupportedConstLiteralDouble();
          break;
        case NONSUPPORTED_IDENTIFIER:
          nonsupportedIdentifier();
          break;
        default:
          jj_la1[36] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } finally {
      trace_return("parseLexical");
    }
  }

  final public void specialSymbol() throws ParseException {
    trace_call("specialSymbol");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ESP_SYMBOL_L_BRACKET:
        jj_consume_token(ESP_SYMBOL_L_BRACKET);
        break;
      case ESP_SYMBOL_R_BRACKET:
        jj_consume_token(ESP_SYMBOL_R_BRACKET);
        break;
      case ESP_SYMBOL_L_PARENTHESIS:
        jj_consume_token(ESP_SYMBOL_L_PARENTHESIS);
        break;
      case ESP_SYMBOL_R_PARENTHESIS:
        jj_consume_token(ESP_SYMBOL_R_PARENTHESIS);
        break;
      case ESP_SYMBOL_L_BRACE:
        jj_consume_token(ESP_SYMBOL_L_BRACE);
        break;
      case ESP_SYMBOL_R_BRACE:
        jj_consume_token(ESP_SYMBOL_R_BRACE);
        break;
      case ESP_SYMBOL_DOT:
        jj_consume_token(ESP_SYMBOL_DOT);
        break;
      case ESP_SYMBOL_COMA:
        jj_consume_token(ESP_SYMBOL_COMA);
        break;
      case ESP_SYMBOL_ASSIGNE:
        jj_consume_token(ESP_SYMBOL_ASSIGNE);
        break;
      case ESP_SYMBOL_PLUS:
        jj_consume_token(ESP_SYMBOL_PLUS);
        break;
      case ESP_SYMBOL_MINUS:
        jj_consume_token(ESP_SYMBOL_MINUS);
        break;
      case ESP_SYMBOL_STAR:
        jj_consume_token(ESP_SYMBOL_STAR);
        break;
      case ESP_SYMBOL_DIVISION_REAL:
        jj_consume_token(ESP_SYMBOL_DIVISION_REAL);
        break;
      case ESP_SYMBOL_POWER:
        jj_consume_token(ESP_SYMBOL_POWER);
        break;
      case ESP_SYMBOL_DIVISION_INT:
        jj_consume_token(ESP_SYMBOL_DIVISION_INT);
        break;
      case ESP_SYMBOL_MOD:
        jj_consume_token(ESP_SYMBOL_MOD);
        break;
      case ESP_SYMBOL_EQUAL:
        jj_consume_token(ESP_SYMBOL_EQUAL);
        break;
      case ESP_SYMBOL_DIFFERENT:
        jj_consume_token(ESP_SYMBOL_DIFFERENT);
        break;
      case ESP_SYMBOL_GREATER:
        jj_consume_token(ESP_SYMBOL_GREATER);
        break;
      case ESP_SYMBOL_LESSER:
        jj_consume_token(ESP_SYMBOL_LESSER);
        break;
      case ESP_SYMBOL_GREATEREQUAL:
        jj_consume_token(ESP_SYMBOL_GREATEREQUAL);
        break;
      case ESP_SYMBOL_LESSERREQUAL:
        jj_consume_token(ESP_SYMBOL_LESSERREQUAL);
        break;
      case ESP_SYMBOL_AND:
        jj_consume_token(ESP_SYMBOL_AND);
        break;
      case ESP_SYMBOL_OR:
        jj_consume_token(ESP_SYMBOL_OR);
        break;
      case ESP_SYMBOL_NOT:
        jj_consume_token(ESP_SYMBOL_NOT);
        break;
      default:
        jj_la1[37] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        //lexicalAnalysis.printRecognizedToken(token.image, "Simbolo Especial", token.kind, token.beginLine, token.beginColumn);
    } finally {
      trace_return("specialSymbol");
    }
  }

  final public void reservedWord() throws ParseException {
    trace_call("reservedWord");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RESERVED_WORD_DO:
        jj_consume_token(RESERVED_WORD_DO);
        break;
      case RESERVED_WORD_THIS:
        jj_consume_token(RESERVED_WORD_THIS);
        break;
      case RESERVED_WORD_BODY:
        jj_consume_token(RESERVED_WORD_BODY);
        break;
      case RESERVED_WORD_DESCRIPTION:
        jj_consume_token(RESERVED_WORD_DESCRIPTION);
        break;
      case RESERVED_WORD_DECLARATION:
        jj_consume_token(RESERVED_WORD_DECLARATION);
        break;
      case RESERVED_WORD_TYPE:
        jj_consume_token(RESERVED_WORD_TYPE);
        break;
      case RESERVED_WORD_IS:
        jj_consume_token(RESERVED_WORD_IS);
        break;
      case RESERVED_WORD_CONSTANT:
        jj_consume_token(RESERVED_WORD_CONSTANT);
        break;
      case RESERVED_WORD_AND:
        jj_consume_token(RESERVED_WORD_AND);
        break;
      case RESERVED_WORD_VARIABLE:
        jj_consume_token(RESERVED_WORD_VARIABLE);
        break;
      case RESERVED_WORD_AS:
        jj_consume_token(RESERVED_WORD_AS);
        break;
      case RESERVED_WORD_INTEGER:
        jj_consume_token(RESERVED_WORD_INTEGER);
        break;
      case RESERVED_WORD_REAL:
        jj_consume_token(RESERVED_WORD_REAL);
        break;
      case RESERVED_WORD_STRING:
        jj_consume_token(RESERVED_WORD_STRING);
        break;
      case RESERVED_WORD_LOGIC:
        jj_consume_token(RESERVED_WORD_LOGIC);
        break;
      case RESERVED_WORD_DESIGNATE:
        jj_consume_token(RESERVED_WORD_DESIGNATE);
        break;
      case RESERVED_WORD_READ:
        jj_consume_token(RESERVED_WORD_READ);
        break;
      case RESERVED_WORD_WRITE:
        jj_consume_token(RESERVED_WORD_WRITE);
        break;
      case RESERVED_WORD_ALL:
        jj_consume_token(RESERVED_WORD_ALL);
        break;
      case RESERVED_WORD_REPEAT:
        jj_consume_token(RESERVED_WORD_REPEAT);
        break;
      case RESERVED_WORD_AVALIATE:
        jj_consume_token(RESERVED_WORD_AVALIATE);
        break;
      case RESERVED_WORD_RESULT:
        jj_consume_token(RESERVED_WORD_RESULT);
        break;
      case RESERVED_WORD_TRUE:
        jj_consume_token(RESERVED_WORD_TRUE);
        break;
      case RESERVED_WORD_UNTRUE:
        jj_consume_token(RESERVED_WORD_UNTRUE);
        break;
      default:
        jj_la1[38] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        //lexicalAnalysis.printRecognizedToken(token.image, "Palavra Reservada", token.kind, token.beginLine, token.beginColumn);
    } finally {
      trace_return("reservedWord");
    }
  }

  final public void constInt() throws ParseException {
    trace_call("constInt");
    try {
      jj_consume_token(CONST_INT);
        //lexicalAnalysis.printRecognizedToken(token.image, "Constante Inteira", token.kind, token.beginLine, token.beginColumn);
    } finally {
      trace_return("constInt");
    }
  }

  final public void constReal() throws ParseException {
    trace_call("constReal");
    try {
      jj_consume_token(CONST_REAL);
        //lexicalAnalysis.printRecognizedToken(token.image, "Constante Real", token.kind, token.beginLine, token.beginColumn);
    } finally {
      trace_return("constReal");
    }
  }

  final public void constLiteral() throws ParseException {
    trace_call("constLiteral");
    try {
      jj_consume_token(CONST_LITERAL);
        //lexicalAnalysis.printRecognizedToken(token.image, "Constante Literal", token.kind, token.beginLine, token.beginColumn);
    } finally {
      trace_return("constLiteral");
    }
  }

  final public void identifier() throws ParseException {
    trace_call("identifier");
    try {
      jj_consume_token(IDENTIFIER);
        //lexicalAnalysis.printRecognizedToken(token.image, "Identificador", token.kind, token.beginLine, token.beginColumn);
    } finally {
      trace_return("identifier");
    }
  }

  final public void nonsupportedSymbol() throws ParseException {
    trace_call("nonsupportedSymbol");
    try {
                              lexErrorCount++;
      jj_consume_token(NONSUPPORTED_SYMBOL);
        compile.printNotRecognizedToken(token.image, "Simbolo nao suportado", token.kind, token.beginLine, token.beginColumn);
    } finally {
      trace_return("nonsupportedSymbol");
    }
  }

  final public void nonsupportedConstLiteralSingle() throws ParseException {
    trace_call("nonsupportedConstLiteralSingle");
    try {
                                          lexErrorCount++;
      jj_consume_token(NONSUPPORTED_CONST_LITERAL_SINGLE);
        compile.printNotRecognizedToken(token.image, "Constante literal nao suportada, faltando aspas simples", token.kind, token.beginLine, token.beginColumn);
    } finally {
      trace_return("nonsupportedConstLiteralSingle");
    }
  }

  final public void nonsupportedConstLiteralDouble() throws ParseException {
    trace_call("nonsupportedConstLiteralDouble");
    try {
                                          lexErrorCount++;
      jj_consume_token(NONSUPPORTED_CONST_LITERAL_DOUBLE);
        compile.printNotRecognizedToken(token.image, "Constante literal nao suportada. faltando aspas duplas", token.kind, token.beginLine, token.beginColumn);
;
    } finally {
      trace_return("nonsupportedConstLiteralDouble");
    }
  }

  final public void nonsupportedBlockComment() throws ParseException {
    trace_call("nonsupportedBlockComment");
    try {
                                    lexErrorCount++;
      jj_consume_token(NONSUPPORTED_BLOCK_COMMENT);
        compile.printNotRecognizedToken(token.image, "Nao contem o fechamento do bloco de comentario", token.kind, token.beginLine, token.beginColumn);
    } finally {
      trace_return("nonsupportedBlockComment");
    }
  }

  final public void nonsupportedIdentifier() throws ParseException {
    trace_call("nonsupportedIdentifier");
    try {
                                  lexErrorCount++;
      jj_consume_token(NONSUPPORTED_IDENTIFIER);
        compile.printNotRecognizedToken(token.image, "Identificador invalido", token.kind, token.beginLine, token.beginColumn);
    } finally {
      trace_return("nonsupportedIdentifier");
    }
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_3R_19() {
    if (jj_3R_24()) return true;
    return false;
  }

  private boolean jj_3R_18() {
    if (jj_3R_23()) return true;
    return false;
  }

  private boolean jj_3R_24() {
    if (!jj_rescan) trace_call("CmdDataOutput(LOOKING AHEAD...)");
    if (jj_scan_token(RESERVED_WORD_WRITE)) { if (!jj_rescan) trace_return("CmdDataOutput(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("CmdDataOutput(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_10() {
    if (!jj_rescan) trace_call("EvaluateRepTrue(LOOKING AHEAD...)");
    if (jj_scan_token(ESP_SYMBOL_L_BRACKET)) { if (!jj_rescan) trace_return("EvaluateRepTrue(LOOKAHEAD FAILED)"); return true; }
    if (jj_3R_13()) { if (!jj_rescan) trace_return("EvaluateRepTrue(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("EvaluateRepTrue(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_17() {
    if (jj_3R_22()) return true;
    return false;
  }

  private boolean jj_3R_16() {
    if (!jj_rescan) trace_call("Command(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_17()) {
    jj_scanpos = xsp;
    if (jj_3R_18()) {
    jj_scanpos = xsp;
    if (jj_3R_19()) {
    jj_scanpos = xsp;
    if (jj_3R_20()) {
    jj_scanpos = xsp;
    if (jj_3R_21()) { if (!jj_rescan) trace_return("Command(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    }
    { if (!jj_rescan) trace_return("Command(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_12() {
    if (jj_scan_token(ESP_SYMBOL_COMA)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_3R_9()) return true;
    return false;
  }

  private boolean jj_3R_15() {
    if (jj_3R_16()) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_3R_10()) return true;
    return false;
  }

  private boolean jj_3R_13() {
    if (!jj_rescan) trace_call("CommandList(LOOKING AHEAD...)");
    Token xsp;
    if (jj_3R_15()) { if (!jj_rescan) trace_return("CommandList(LOOKAHEAD FAILED)"); return true; }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_15()) { jj_scanpos = xsp; break; }
    }
    { if (!jj_rescan) trace_return("CommandList(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3_1() {
    if (jj_scan_token(RESERVED_WORD_DECLARATION)) return true;
    if (jj_scan_token(RESERVED_WORD_TYPE)) return true;
    return false;
  }

  private boolean jj_3R_23() {
    if (!jj_rescan) trace_call("CmdDataInput(LOOKING AHEAD...)");
    if (jj_scan_token(RESERVED_WORD_READ)) { if (!jj_rescan) trace_return("CmdDataInput(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("CmdDataInput(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_14() {
    if (jj_scan_token(ESP_SYMBOL_L_BRACE)) return true;
    if (jj_scan_token(CONST_INT)) return true;
    return false;
  }

  private boolean jj_3R_11() {
    if (!jj_rescan) trace_call("Index(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_14()) jj_scanpos = xsp;
    { if (!jj_rescan) trace_return("Index(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_25() {
    if (!jj_rescan) trace_call("CmdSelection(LOOKING AHEAD...)");
    if (jj_scan_token(RESERVED_WORD_AVALIATE)) { if (!jj_rescan) trace_return("CmdSelection(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("CmdSelection(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_26() {
    if (!jj_rescan) trace_call("CmdRepetition(LOOKING AHEAD...)");
    if (jj_scan_token(RESERVED_WORD_REPEAT)) { if (!jj_rescan) trace_return("CmdRepetition(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("CmdRepetition(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_9() {
    if (!jj_rescan) trace_call("IdentifierVariablesList(LOOKING AHEAD...)");
    if (jj_scan_token(IDENTIFIER)) { if (!jj_rescan) trace_return("IdentifierVariablesList(LOOKAHEAD FAILED)"); return true; }
    if (jj_3R_11()) { if (!jj_rescan) trace_return("IdentifierVariablesList(LOOKAHEAD FAILED)"); return true; }
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_12()) { jj_scanpos = xsp; break; }
    }
    { if (!jj_rescan) trace_return("IdentifierVariablesList(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_22() {
    if (!jj_rescan) trace_call("CmdAssignment(LOOKING AHEAD...)");
    if (jj_scan_token(RESERVED_WORD_DESIGNATE)) { if (!jj_rescan) trace_return("CmdAssignment(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("CmdAssignment(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_21() {
    if (jj_3R_26()) return true;
    return false;
  }

  private boolean jj_3R_20() {
    if (jj_3R_25()) return true;
    return false;
  }

  /** Generated Token Manager. */
  public LParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  /** Whether we are looking ahead. */
  private boolean jj_lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[39];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000,0x800,0x0,0x1f800000,0x1f800000,0x40030000,0x40030000,0x206c0000,0x206c0000,0x100000,0x1000200,0x0,0x0,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0xffffff80,0xffffff80,0xffffff80,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x8,0x0,0x0,0x10,0x400,0x400,0x280,0x0,0x0,0x7800,0xc00000,0x0,0x0,0x0,0x0,0x7800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe0c00000,0x40002,0x0,0x0,0xe0000000,0xe0000000,0x800000,0x400000,0xc00000,0x1b8000,0x1b8000,0x0,0xe0ffffff,0xe0ffffff,0x0,0xffffff,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x0,0x0,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x1,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3f,0x3f,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[3];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public LParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public LParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new LParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 39; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 39; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public LParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new LParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 39; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 39; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public LParser(LParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 39; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(LParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 39; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      trace_token(token, "");
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    } else {
      trace_scan(jj_scanpos, kind);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
      trace_token(token, " (in getNextToken)");
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = jj_lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List jj_expentries = new java.util.ArrayList();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Iterator it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.add(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[70];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 39; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 70; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  private int trace_indent = 0;
  private boolean trace_enabled = true;

/** Enable tracing. */
  final public void enable_tracing() {
    trace_enabled = true;
  }

/** Disable tracing. */
  final public void disable_tracing() {
    trace_enabled = false;
  }

  private void trace_call(String s) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Call:   " + s);
    }
    trace_indent = trace_indent + 2;
  }

  private void trace_return(String s) {
    trace_indent = trace_indent - 2;
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Return: " + s);
    }
  }

  private void trace_token(Token t, String where) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Consumed token: <" + tokenImage[t.kind]);
      if (t.kind != 0 && !tokenImage[t.kind].equals("\"" + t.image + "\"")) {
        System.out.print(": \"" + t.image + "\"");
      }
      System.out.println(" at line " + t.beginLine + " column " + t.beginColumn + ">" + where);
    }
  }

  private void trace_scan(Token t1, int t2) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Visited token: <" + tokenImage[t1.kind]);
      if (t1.kind != 0 && !tokenImage[t1.kind].equals("\"" + t1.image + "\"")) {
        System.out.print(": \"" + t1.image + "\"");
      }
      System.out.println(" at line " + t1.beginLine + " column " + t1.beginColumn + ">; Expected token: <" + tokenImage[t2] + ">");
    }
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 3; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
