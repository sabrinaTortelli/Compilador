options {
    STATIC = false;
    IGNORE_CASE = false;
    DEBUG_LOOKAHEAD = true;
}

PARSER_BEGIN(LParser)


package br.univali.compiladores.compilador.model.parser;
import br.univali.compiladores.compilador.model.Compile.Compile;
import br.univali.compiladores.compilador.model.recovery.First;
import br.univali.compiladores.compilador.model.recovery.RecoverySet;
import br.univali.compiladores.compilador.model.recovery.ParseEOFException;
import br.univali.compiladores.compilador.view.WindowER;
import br.univali.compiladores.compilador.model.Compile.SemanticActions;

public class LParser
{
    private Compile compile;
    private int lexErrorCount;
    private int synErrorCount;
    private SemanticActions semanticActions;


    //para o AS
    private boolean debug_recovery = true;
    private boolean eof; // indica se encontramos o end of file
    private Token lastError = null;

    static public String im(int x)
    {
        int k;
        String s;
            s = tokenImage[x];
            k = s.lastIndexOf("\"");
            try{
                s =s.substring(1,k);
            }catch (StringIndexOutOfBoundsException e){
                System.err.println(e.getMessage());
            }
            return s;
    }

    void consumeUntil(RecoverySet g,ParseException e, String met) throws ParseEOFException, ParseException
    {
        Token tok;
        System.out.println("reading " + met);
        if (debug_recovery)
        {
            System.out.println();
            System.out.println("*** " + met + " ***");
            System.out.println("    Synchronizing Set: " + g);
        }
        if (g == null) throw e;
        tok = getToken(1);
        while (!eof)
        {
            if(g.contains(tok.kind))
                {
                    if(debug_recovery) System.out.println("    Found synchronizing token: " + im(tok.kind));
                    break;
                }
            if(debug_recovery)
                System.out.println("    Ignoring token: " + im(tok.kind));
            getNextToken();
            tok = getToken(1);
            if (tok.kind == EOF && !g.contains(EOF))
                eof = true;
        }
        if(tok != lastError)
        {
         System.out.println(e.getMessage());
         synErrorCount++;
         lastError = tok;
        }
        compile.printNotRecognized(g, e, met);

        //System.out.println(e.getMessage());
        //synErrorCount++;
        if (eof) throw  new ParseEOFException("EOF found prematurely");
    }
    
    public int getLexErrorCount() {
        return lexErrorCount;
    }

    public int getSynErrorCount() {
        return synErrorCount;
    }

    public void setLexicalAnalysis(WindowER gui){
        compile = new Compile(gui);
        semanticActions = new SemanticActions();
    }
}

PARSER_END(LParser)


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <LINE_COMMENT:("#" (~["\n","\r"])* ("\n"|"\r"|"\r\n"))> /*LINE COMMENT*/
| <BLOCK_COMMENT: ("@" ((~["@"])*|"\n"|"\r"|"\r\n")* "@")>/*BLOCK COMMENT*/
}

TOKEN /*SPECIAL_SYMBOLS*/:
{
  <ESP_SYMBOL_L_BRACKET: "[">
| <ESP_SYMBOL_R_BRACKET: "]">
| <ESP_SYMBOL_L_PARENTHESIS: "(">
| <ESP_SYMBOL_R_PARENTHESIS: ")">
| <ESP_SYMBOL_L_BRACE: "{">
| <ESP_SYMBOL_R_BRACE: "}">
| <ESP_SYMBOL_DOT: ".">
| <ESP_SYMBOL_COMA: ",">
| <ESP_SYMBOL_ASSIGNE: "=">
| <ESP_SYMBOL_PLUS: "+">
| <ESP_SYMBOL_MINUS: "-">
| <ESP_SYMBOL_STAR: "*">
| <ESP_SYMBOL_DIVISION_REAL: "/">
| <ESP_SYMBOL_POWER: "**">
| <ESP_SYMBOL_DIVISION_INT: "%">
| <ESP_SYMBOL_MOD: "%%">
| <ESP_SYMBOL_EQUAL: "==">
| <ESP_SYMBOL_DIFFERENT: "!=">
| <ESP_SYMBOL_GREATER: ">>">
| <ESP_SYMBOL_LESSER: "<<">
| <ESP_SYMBOL_GREATEREQUAL: ">>=">
| <ESP_SYMBOL_LESSERREQUAL: "<<=">
| <ESP_SYMBOL_AND:  "&">
| <ESP_SYMBOL_OR:  "|">
| <ESP_SYMBOL_NOT: "!">
}

TOKEN /*RESERVED WORDS*/:
{
  <RESERVED_WORD_DO:("D"|"d")("O"|"o")>
| <RESERVED_WORD_THIS:("T"|"t")("H"|"h")("I"|"i")("S"|"s")>
| <RESERVED_WORD_BODY:("B"|"b")("O"|"o")("D"|"d")("Y"|"y")>
| <RESERVED_WORD_DESCRIPTION:("D"|"d")("E"|"e")("S"|"s")("C"|"c")("R"|"r")("I"|"i")("P"|"p")("T"|"t")("I"|"i")("O"|"o")("N"|"n")>
| <RESERVED_WORD_DECLARATION: ("D"|"d")("E"|"e")("C"|"c")("L"|"l")("A"|"a")("R"|"r")("A"|"a")("T"|"t")("I"|"i")("O"|"o")("N"|"n")>
| <RESERVED_WORD_TYPE:("T"|"t")("Y"|"y")("P"|"p")("E"|"e")>
| <RESERVED_WORD_IS:("I"|"i")("S"|"s")>
| <RESERVED_WORD_CONSTANT:("C"|"c")("O"|"o")("N"|"n")("S"|"s")("T"|"t")("A"|"a")("N"|"n")("T"|"t")>
| <RESERVED_WORD_AND:("A"|"a")("N"|"n")("D"|"d")>
| <RESERVED_WORD_VARIABLE:("V"|"v")("A"|"a")("R"|"r")("I"|"i")("A"|"a")("B"|"b")("L"|"l")("E"|"e")>
| <RESERVED_WORD_AS:("A"|"a")("S"|"s")>
| <RESERVED_WORD_INTEGER:("I"|"i")("N"|"n")("T"|"t")("E"|"e")("G"|"g")("E"|"e")("R"|"r")>
| <RESERVED_WORD_REAL:("R"|"r")("E"|"e")("A"|"a")("L"|"l")>
| <RESERVED_WORD_STRING:("S"|"s")("T"|"t")("R"|"r")("I"|"i")("N"|"n")("G"|"g")>
| <RESERVED_WORD_LOGIC:("L"|"l")("O"|"o")("G"|"g")("I"|"i")("C"|"c")>
| <RESERVED_WORD_DESIGNATE:("D"|"d")("E"|"e")("S"|"s")("I"|"i")("G"|"g")("N"|"n")("A"|"a")("T"|"t")("E"|"e")>
| <RESERVED_WORD_READ:("R"|"r")("E"|"e")("A"|"a")("D"|"d")>
| <RESERVED_WORD_WRITE:("W"|"w")("R"|"r")("I"|"i")("T"|"t")("E"|"e")>
| <RESERVED_WORD_ALL:("A"|"a")("L"|"l")("L"|"l")>
| <RESERVED_WORD_REPEAT:("R"|"r")("E"|"e")("P"|"p")("E"|"e")("A"|"a")("T"|"t")>
| <RESERVED_WORD_AVALIATE:("A"|"a")("V"|"v")("A"|"a")("L"|"l")("I"|"i")("A"|"a")("T"|"t")("E"|"e")>
| <RESERVED_WORD_RESULT:("R"|"r")("E"|"e")("S"|"s")("U"|"u")("L"|"l")("T"|"t")>
| <RESERVED_WORD_TRUE:("T"|"t")("R"|"r")("U"|"u")("E"|"e")>
| <RESERVED_WORD_UNTRUE:("U"|"u")("N"|"n")("T"|"t")("R"|"r")("U"|"u")("E"|"e")>
}

TOKEN : { < #DIGIT : ["0"-"9"] > }
TOKEN : { < #LETTER : ["a"-"z","A"-"Z"] > }
TOKEN : { < #CAPSLETTER : ["A"-"Z"] > }
TOKEN : { < #LOWCAPSLETTER : ["a"-"z"] > }
TOKEN : { < #UNDER : ["_"] > }


TOKEN : /* INT */
{
  < CONST_INT: (<DIGIT>) | (<DIGIT>){2} | (<DIGIT>){3} >
}

TOKEN : /* REAL */
{
  < CONST_REAL: ((<DIGIT>) | (<DIGIT>){2} | (<DIGIT>){3} | (<DIGIT>){4} | (<DIGIT>){5}) "." ((<DIGIT>) | (<DIGIT>){2} | (<DIGIT>){3}) >
}

TOKEN : /* LITERAL */
{
  < CONST_LITERAL: ("\"" (~["\""])* "\"") | ("\'" (~["'"])* "\'") >
}


TOKEN : {
    /*<IDENTIFIER:(<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|(((<UNDER>)((<LETTER>)+(<DIGIT>){0,2}|(<DIGIT>){1,2}))|((<LETTER>)+(<DIGIT>){0,2}))*((<UNDER>)|(<LETTER>)+(<UNDER>)?)) >*/

    <IDENTIFIER:(<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*)>

}

TOKEN :
{
    < NONSUPPORTED_SYMBOL/* throws error for any token not listed bellow */:
    (~ ["a"-"z", "A"-"Z", "0"-"9", "@","\"", "'", "&",
        "(", ")", "[", "]", "{", "}", ",", ".", "=",
        ">", "<", "!", "+", "-", "*", "/", "%", "|",
        "$", "#", " ", "\t", "\n","\r", "\f"]
    )+ >
|   < NONSUPPORTED_CONST_LITERAL_SINGLE/* throws error for any open and not closed single quote */:
    ("'" (~ ["'"])*)
    >
|   < NONSUPPORTED_CONST_LITERAL_DOUBLE/* throws error for any open and not closed double quote */:
    ("\"" (~ ["\""])*)
    >
|   < NONSUPPORTED_BLOCK_COMMENT/* throws error for any open and not closed block comment  */:
    ("@" ((~["@"])*|"\n"|"\r"|"\r\n")*)
    >
|   < NONSUPPORTED_IDENTIFIER/* throws error for non valid identifiers  */:
    (
        /*starting with low caps letter*/
        ((<LOWCAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*))

        /*caps letter followed by 3 digits r2*/
        |((<CAPSLETTER>)((((<DIGIT>){2}(<DIGIT>)+((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*))

        /*caps letter followed by 3 digits r4*/
        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){2}(<DIGIT>)+((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*))

        /*caps letter followed by double_ or more*/
        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>){2}(<UNDER>)*|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*))

        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>){2}(<UNDER>)*))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*))

        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>){2}(<UNDER>)*))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*))

        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>){2}(<UNDER>)+(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*))

        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>){2}(<UNDER>)+)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*))

        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>){2}(<UNDER>)*(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*))

        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>){2}(<UNDER>)*|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*))

        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>){2}(<UNDER>)*))|((<LETTER>)+(<UNDER>)?))*))

        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>){2}(<UNDER>)*))*))

        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>){2}(<UNDER>)*|(<UNDER>){2}(<UNDER>)*))|((<LETTER>)+(<UNDER>){2}(<UNDER>)*))*|((<UNDER>){2}(<UNDER>)*(<LETTER>)+(<UNDER>){2}(<UNDER>)*)*|((<UNDER>){2}(<UNDER>)*(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>){2}(<UNDER>)*|(<UNDER>){2}(<UNDER>)*))|((<LETTER>)+(<UNDER>){2}(<UNDER>)*))*))

        /*caps letter finishing with numbers*/
        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*)(<DIGIT>)+)
    )
    >
}


//syntactical analysis
public void parseSyntactical() throws ParseEOFException : {}
{
    readProgram()
}

void readProgram() throws ParseEOFException:
{
    RecoverySet g = new RecoverySet(EOF);
}
{
try{
        Program(g)<EOF>
    }
    catch (ParseException e){
        consumeUntil(g, e, "read program");
    }
}

void Program(RecoverySet g) throws ParseEOFException :
{
    RecoverySet f1 = First.Comment.union(g),
            f2 = First.ProgramBody.union(f1);
}
{
    try{
        <RESERVED_WORD_DO> <RESERVED_WORD_THIS> <IDENTIFIER> <ESP_SYMBOL_L_BRACKET>
        <ESP_SYMBOL_R_BRACKET> Declaration(f2) ProgramBody(f1) Comment(g)
    }
    catch (ParseException e){
        consumeUntil(g, e, "program declaration");
    }
}

void Comment(RecoverySet g) throws ParseEOFException :
{
}
{
    try{
        [<RESERVED_WORD_DESCRIPTION> <CONST_LITERAL>]
    }
    catch (ParseException e){
        consumeUntil(g, e, "Comment");
    }
}

void Declaration(RecoverySet g) throws ParseEOFException :
{
}
{
    try{
        [<RESERVED_WORD_DECLARATION> DeclarationL(g)]
    }
    catch (ParseException e){
        consumeUntil(g, e, "declaration");
    }
}

void DeclarationL(RecoverySet g) throws ParseEOFException :
{
 RecoverySet f1 = new RecoverySet(ESP_SYMBOL_R_BRACKET).union(g);
}
{
    try{
        <RESERVED_WORD_TYPE> <ESP_SYMBOL_L_BRACKET> DeclarationEnumeratedType(f1) <ESP_SYMBOL_R_BRACKET> DeclarationLL(g) |
        DeclarationConstantsAndVariables(g)
    }
    catch (ParseException e){
        consumeUntil(g, e, "Declaration L");
    }
}

void DeclarationLL(RecoverySet g) throws ParseEOFException :
{
}
{
    try{
        [<RESERVED_WORD_DECLARATION> DeclarationConstantsAndVariables(g)]
    }
    catch (ParseException e){
        consumeUntil(g, e, "Declaration LL");
    }
}

//DeclarationEnumeratedType block
void DeclarationEnumeratedType(RecoverySet g) throws ParseEOFException:
{
 RecoverySet f1 = new RecoverySet(ESP_SYMBOL_DOT).union(g);
}
{
    try{
        <IDENTIFIER> <RESERVED_WORD_IS> IdentifierEnumTypeDeclarationList(f1)
        <ESP_SYMBOL_DOT> DeclarationEnumeratedTypeL(g)
    }
    catch(ParseException e){
        consumeUntil(g, e, "Declaration Enumerated Type");
    }
}

void DeclarationEnumeratedTypeL(RecoverySet g) throws ParseEOFException:
{
}
{
    try{
        [DeclarationEnumeratedType(g)]
    }
    catch(ParseException e){
        consumeUntil(g, e, "Declaration Enumerated Type L");
    }
}

void IdentifierEnumTypeDeclarationList(RecoverySet g) throws ParseEOFException:
{
}
{
    try{
        <IDENTIFIER> IdentifierEnumTypeDeclarationListL(g)
    }
    catch(ParseException e){
        consumeUntil(g, e, "Identifier Enum Type Declaration List");
    }
}

void IdentifierEnumTypeDeclarationListL(RecoverySet g) throws ParseEOFException:
{
}
{
    try{
        [<ESP_SYMBOL_COMA> IdentifierEnumTypeDeclarationList(g)]
    }
    catch(ParseException e){
        consumeUntil(g, e, "Identifier Enum Type Declaration List L");
    }
}

void DeclarationConstantsAndVariables(RecoverySet g) throws ParseEOFException:
{
    RecoverySet f1 = new RecoverySet(ESP_SYMBOL_R_BRACKET).union(g);
}
{
    try{
        <RESERVED_WORD_CONSTANT> <RESERVED_WORD_AND> <RESERVED_WORD_VARIABLE> <ESP_SYMBOL_L_BRACKET> ConstantsAndVariables(f1) <ESP_SYMBOL_R_BRACKET>
    }
    catch(ParseException e){
        consumeUntil(g, e, "declaration constants and varibles");
    }
}

void ConstantsAndVariables(RecoverySet g) throws ParseEOFException:
{}
{
    try{
        <RESERVED_WORD_AS> ConstantAndVariablesL(g)
    }
    catch(ParseException e){
        consumeUntil(g, e, "Constants And Variables");
    }
}

void ConstantAndVariablesL(RecoverySet g) throws ParseEOFException:
{
 RecoverySet f1 = First.VariablesLL.union(g),
             f2 = First.ConstantsLL.union(g);
}
{
    try{
        ConstantsDeclaration(f1) VariablesLL(g) | VariablesDeclaration(f2) ConstantsLL(g)
    }
    catch(ParseException e){
        consumeUntil(g, e, "Constant And Variables L");
    }
}

// Constants Declaration sub block
void ConstantsDeclaration(RecoverySet g) throws ParseEOFException:
{
}
{
    try{
        <RESERVED_WORD_CONSTANT> Constants(g)
    }
    catch(ParseException e){
        consumeUntil(g, e, "Constants Declaration");
    }
}

void Constants(RecoverySet g) throws ParseEOFException:
{
  RecoverySet f1 = new RecoverySet(RESERVED_WORD_IS).union(g),
             f2 = new RecoverySet(ESP_SYMBOL_EQUAL).union(g),
             f3 = new RecoverySet(ESP_SYMBOL_DOT).union(g);
}
{
    try{
        IdentifierConstantsList(f1) <RESERVED_WORD_IS> Type(f2)
         <ESP_SYMBOL_ASSIGNE> Value(f3) <ESP_SYMBOL_DOT> ConstantsL(g)
    }
    catch(ParseException e){
        consumeUntil(g, e, "Constants");
    }
}

void ConstantsL(RecoverySet g) throws ParseEOFException:
{
}
{
    try{
        [Constants(g)]
    }
    catch(ParseException e){
        consumeUntil(g, e, "Constants L");
    }
}

void ConstantsLL(RecoverySet g) throws ParseEOFException:
{
}
{
    try{
        [<RESERVED_WORD_AS> ConstantsDeclaration(g)]
    }
    catch(ParseException e){
        consumeUntil(g, e, "Constants LL");
    }
}

void VariablesDeclaration(RecoverySet g) throws ParseEOFException:
{
}
{
    try{
        <RESERVED_WORD_VARIABLE> Variables(g)
    }
    catch(ParseException e){
        consumeUntil(g, e, "Variables Declaration");
    }
}

void Variables(RecoverySet g) throws ParseEOFException:
{
 RecoverySet f1 = new RecoverySet(RESERVED_WORD_IS).union(g),
             f2 = new RecoverySet(ESP_SYMBOL_DOT).union(g);
}
{
    try{
        VariablesIdentifiersList(f1) <RESERVED_WORD_IS> Type(f2)
        <ESP_SYMBOL_DOT> VariablesL(g)
    }
    catch(ParseException e){
        consumeUntil(g, e, "Variables");
    }
}

void VariablesL(RecoverySet g) throws ParseEOFException:
{
}
{
    try{
        [Variables(g)]
    }
    catch(ParseException e){
        consumeUntil(g, e, "Variables L");
    }
}

void VariablesLL(RecoverySet g) throws ParseEOFException:
{
}
{
    try{
        [<RESERVED_WORD_AS> VariablesDeclaration(g)]
    }
    catch(ParseException e){
        consumeUntil(g, e, "Variables LL");
    }
}

void IdentifierConstantsList(RecoverySet g) throws ParseEOFException:
{
}
{
    try{
        <IDENTIFIER> IdentifierConstantsListL(g)
    }
    catch(ParseException e){
        consumeUntil(g, e, "Identifier Constants List");
    }
}

void IdentifierConstantsListL(RecoverySet g) throws ParseEOFException:
{
}
{
    try{
        [<ESP_SYMBOL_COMA> IdentifierConstantsList(g)]
    }
    catch(ParseException e){
        consumeUntil(g, e, "Identifier Constants List L");
    }
}

void VariablesIdentifiersList(RecoverySet g) throws ParseEOFException:
{
 RecoverySet f1 = First.VariablesIdentifiersListL.union(g);
}
{
    try{
        <IDENTIFIER> Index(f1) VariablesIdentifiersListL(g)
    }
    catch(ParseException e){
        consumeUntil(g, e, "Variables Identifiers List");
    }
}

void VariablesIdentifiersListL(RecoverySet g) throws ParseEOFException:
{
}
{
    try{
        [<ESP_SYMBOL_COMA> VariablesIdentifiersList(g)]
    }
    catch(ParseException e){
        consumeUntil(g, e, "Variables Identifiers List L");
    }
}

void Index(RecoverySet g) throws ParseEOFException:
{
}
{
    try{
        [<ESP_SYMBOL_L_BRACE> <CONST_INT> <ESP_SYMBOL_R_BRACE>]
    }
    catch(ParseException e){
        consumeUntil(g, e, "index");
    }
}

void Type(RecoverySet g) throws ParseEOFException:
{
}
{
    try{
        <RESERVED_WORD_INTEGER> | <RESERVED_WORD_REAL> |
        <RESERVED_WORD_STRING> | <RESERVED_WORD_LOGIC> |
        <IDENTIFIER>
    }
    catch(ParseException e){
        consumeUntil(g, e, "type");
    }
}

void Value(RecoverySet g) throws ParseEOFException:
{}
{
    try{
        <CONST_INT> | <CONST_REAL> | <CONST_LITERAL>
    }
    catch(ParseException e){
        consumeUntil(g, e, "value");
    }
}

void ProgramBody(RecoverySet g) throws ParseEOFException:
{
 RecoverySet f1 = new RecoverySet(ESP_SYMBOL_R_BRACKET).union(g);
}
{
    try{
        <RESERVED_WORD_BODY> <ESP_SYMBOL_L_BRACKET> CommandList(f1) <ESP_SYMBOL_R_BRACKET>
    }
    catch(ParseException e){
        consumeUntil(g, e, "Program Body");
    }
}

void CommandList(RecoverySet g) throws ParseEOFException:
{
 RecoverySet f1 = First.CommandListL.union(g);
}
{
    try{
        Command(f1) CommandListL(g)
    }
    catch(ParseException e){
        consumeUntil(g, e, "command list");
    }
}

void CommandListL(RecoverySet g) throws ParseEOFException:
{}
{
    try{
        [CommandList(g)]
    }
    catch(ParseException e){
        consumeUntil(g, e, "command list L");
    }
}

void Command(RecoverySet g) throws ParseEOFException:
{}
{
    try{
        CmdAssignment(g)
        | CmdDataInput(g)
        | CmdDataOutput(g)
        | CmdSelection(g)
        | CmdRepetition(g)
    }
    catch(ParseException e){
        consumeUntil(g, e, "command");
    }
}

//Assignmeent block
void CmdAssignment(RecoverySet g) throws ParseEOFException:
{
 RecoverySet f1 = new RecoverySet(RESERVED_WORD_AS).union(g),
             f2 = new RecoverySet(ESP_SYMBOL_DOT).union(g);
}
{
    try{
        <RESERVED_WORD_DESIGNATE> <RESERVED_WORD_THIS>
        VariablesIdentifiersList(f1) <RESERVED_WORD_AS> Expression(f2) <ESP_SYMBOL_DOT>
    }
    catch(ParseException e){
        consumeUntil(g, e, "Command Assignment declaration");
    }
}

//Data input block
void CmdDataInput(RecoverySet g) throws ParseEOFException:
{
 RecoverySet f1 = new RecoverySet(ESP_SYMBOL_R_BRACKET).union(g);
}
{
    try{
        <RESERVED_WORD_READ> <RESERVED_WORD_THIS> <ESP_SYMBOL_L_BRACKET>
         VariablesIdentifiersList(f1) <ESP_SYMBOL_R_BRACKET> <ESP_SYMBOL_DOT>
    }
    catch(ParseException e){
        consumeUntil(g, e, "Command Input Data Declaration");
    }
}

//Data output block
void CmdDataOutput(RecoverySet g) throws ParseEOFException:
{}
{
    try{
        <RESERVED_WORD_WRITE> CmdDataOutputL(g)
    }
    catch(ParseException e){
        consumeUntil(g, e, "Command Output Data Declaration");
    }
}

void CmdDataOutputL(RecoverySet g) throws ParseEOFException:
{
 RecoverySet f1 = new RecoverySet(ESP_SYMBOL_R_BRACKET).union(g);
}
{
    try{
        <RESERVED_WORD_ALL> <RESERVED_WORD_THIS> <ESP_SYMBOL_L_BRACKET>
         IndentifierAndOrContantList(f1) <ESP_SYMBOL_R_BRACKET> <ESP_SYMBOL_DOT> |
         <RESERVED_WORD_THIS> <ESP_SYMBOL_L_BRACKET> IndentifierAndOrContantList(f1)
          <ESP_SYMBOL_R_BRACKET> <ESP_SYMBOL_DOT>
    }
    catch(ParseException e){
        consumeUntil(g, e, "Command Output Data Declaration L");
    }
}

void IndentifierAndOrContantList(RecoverySet g) throws ParseEOFException:
{
 RecoverySet f1 = First.IndentifierAndOrContantListL.union(g);
}
{
    try{
        Item(f1) IndentifierAndOrContantListL(g)
    }
    catch(ParseException e){
        consumeUntil(g, e, "Indentifier And Or Contant List");
    }
}

void IndentifierAndOrContantListL(RecoverySet g) throws ParseEOFException:
{}
{
    try{
        [<ESP_SYMBOL_COMA> IndentifierAndOrContantList(g)]
    }
    catch(ParseException e){
        consumeUntil(g, e, "Indentifier And Or Contant List L");
    }
}

void Item(RecoverySet g) throws ParseEOFException:
{}
{
    try{
        <IDENTIFIER> Index(g) |
         <CONST_INT> | <CONST_REAL> |
         <CONST_LITERAL>
    }
    catch(ParseException e){
        consumeUntil(g, e, "item");
    }
}

//Selection command block
void CmdSelection(RecoverySet g) throws ParseEOFException:
{
    RecoverySet f1 = First.CmdSelectionL.union(g);
}
{
    try{
        <RESERVED_WORD_AVALIATE> <RESERVED_WORD_THIS> Expression(f1) CmdSelectionL(g)
    }
    catch(ParseException e){
        consumeUntil(g, e, "Command Select Declaration");
    }
}

void CmdSelectionL(RecoverySet g) throws ParseEOFException:
{
    RecoverySet f1 = new RecoverySet(ESP_SYMBOL_R_BRACKET).union(g),
                f2 = new RecoverySet(ESP_SYMBOL_DOT).union(g);
}
{
    try{
        <RESERVED_WORD_TRUE> <RESERVED_WORD_RESULT> <ESP_SYMBOL_L_BRACKET>
         CommandList(f1) <ESP_SYMBOL_R_BRACKET> False(f2) <ESP_SYMBOL_DOT> |
         <RESERVED_WORD_UNTRUE> <RESERVED_WORD_RESULT> <ESP_SYMBOL_L_BRACKET>
         CommandList(f1) <ESP_SYMBOL_R_BRACKET> True(f2) <ESP_SYMBOL_DOT>
    }
    catch(ParseException e){
        consumeUntil(g, e, "Command Select Declaration L");
    }
}

void True(RecoverySet g) throws ParseEOFException:
{
    RecoverySet f1 = new RecoverySet(ESP_SYMBOL_R_BRACKET).union(g);
}
{
    try{
        [<RESERVED_WORD_TRUE> <RESERVED_WORD_RESULT> <ESP_SYMBOL_L_BRACKET>
        CommandList(f1) <ESP_SYMBOL_R_BRACKET>]
    }
    catch(ParseException e){
        consumeUntil(g, e, "true");
    }
}

void False(RecoverySet g) throws ParseEOFException:
{
    RecoverySet f1 = new RecoverySet(ESP_SYMBOL_R_BRACKET).union(g);
}
{
    try{
        [<RESERVED_WORD_UNTRUE> <RESERVED_WORD_RESULT> <ESP_SYMBOL_L_BRACKET>
        CommandList(f1) <ESP_SYMBOL_R_BRACKET>]
    }
    catch(ParseException e){
        consumeUntil(g, e, "false");
    }
}

void CmdRepetition(RecoverySet g) throws ParseEOFException:
{
RecoverySet f1 = new RecoverySet(ESP_SYMBOL_L_BRACKET).union(g),
            f2 = new RecoverySet(ESP_SYMBOL_R_BRACKET).union(g);
}
{
    try{
        <RESERVED_WORD_REPEAT> <RESERVED_WORD_THIS> Expression(f1)
        <ESP_SYMBOL_L_BRACKET> CommandList(f2)
        <ESP_SYMBOL_R_BRACKET> <ESP_SYMBOL_DOT>
    }
    catch(ParseException e){
        consumeUntil(g, e, "Command Repetition Declaration");
    }
}

void Expression(RecoverySet g) throws ParseEOFException:
{
    RecoverySet f1 = First.ExpressionL.union(g);
}
{
    try{
        ArithmeticOrLogicalExpression(f1) ExpressionL(g)
    }
    catch(ParseException e){
        consumeUntil(g, e, "expression");
    }
}

void ExpressionL(RecoverySet g) throws ParseEOFException:
{}
{
    try{
        [(<ESP_SYMBOL_EQUAL>  ArithmeticOrLogicalExpression(g)
        | <ESP_SYMBOL_DIFFERENT> ArithmeticOrLogicalExpression(g)
        | <ESP_SYMBOL_GREATER>  ArithmeticOrLogicalExpression(g)
        | <ESP_SYMBOL_LESSER> ArithmeticOrLogicalExpression(g)
        | <ESP_SYMBOL_LESSERREQUAL> ArithmeticOrLogicalExpression(g)
        | <ESP_SYMBOL_GREATEREQUAL> ArithmeticOrLogicalExpression(g))]
    }
    catch(ParseException e){
        consumeUntil(g, e, "expressionL");
    }
}

void ArithmeticOrLogicalExpression(RecoverySet g) throws ParseEOFException:
{
    RecoverySet f1 = First.LowestPriority.union(g);
}
{
    try{
        SecondTerm(f1) LowestPriority(g)
    }
    catch(ParseException e){
        consumeUntil(g, e, "arithmetical or logical expression");
    }
}

void LowestPriority(RecoverySet g) throws ParseEOFException:
{
 RecoverySet f1 = First.LowestPriority.union(g);
}
{
    try{
        [(<ESP_SYMBOL_PLUS> SecondTerm(f1) LowestPriority(g)
        | <ESP_SYMBOL_MINUS> SecondTerm(f1) LowestPriority(g)
        | <ESP_SYMBOL_OR> SecondTerm(f1) LowestPriority(g))]
    }
    catch(ParseException e){
        consumeUntil(g, e, "low priority expression values");
    }
}

void SecondTerm(RecoverySet g) throws ParseEOFException:
{
 RecoverySet f1 = First.MediumPriority.union(g);
}
{
    try{
        FirstTerm(f1) MediumPriority(g)
    }
    catch(ParseException e){
        consumeUntil(g, e, "expression second term");
    }
}

void MediumPriority (RecoverySet g) throws ParseEOFException:
{
 RecoverySet f1 = First.MediumPriority.union(g);
}
{
    try{
        [(<ESP_SYMBOL_STAR> FirstTerm(f1) MediumPriority(g)
        | <ESP_SYMBOL_DIVISION_REAL> FirstTerm(f1) MediumPriority(g)
        | <ESP_SYMBOL_DIVISION_INT> FirstTerm(f1) MediumPriority(g)
        | <ESP_SYMBOL_MOD> FirstTerm(f1) MediumPriority(g)
        | <ESP_SYMBOL_AND> FirstTerm(f1) MediumPriority(g))]
    }
    catch(ParseException e){
        consumeUntil(g, e, "medium priority expression values");
    }
}

void FirstTerm(RecoverySet g) throws ParseEOFException:
{
 RecoverySet f1 = First.HighestPriority.union(g);
}
{
    try{
        Element(f1) HighestPriority(g)
    }
    catch(ParseException e){
        consumeUntil(g, e, "expression first term");
    }
}

void HighestPriority(RecoverySet g) throws ParseEOFException:
{
 RecoverySet f1 = First.HighestPriority.union(g);
}
{
    try{
        [<ESP_SYMBOL_POWER> Element(f1) HighestPriority(g)]
    }
    catch(ParseException e){
        consumeUntil(g, e, "high priority expression values");
    }
}

void Element(RecoverySet g) throws ParseEOFException:
{
 RecoverySet f1 = new RecoverySet(ESP_SYMBOL_R_PARENTHESIS).union(g);
 }
{
    try{
        <IDENTIFIER> Index(g)
        | <CONST_INT> 
        | <CONST_REAL>
        | <CONST_LITERAL>
        | <RESERVED_WORD_TRUE>
        | <RESERVED_WORD_UNTRUE>
        | <ESP_SYMBOL_L_PARENTHESIS> Expression(f1) <ESP_SYMBOL_R_PARENTHESIS>
        | <ESP_SYMBOL_NOT> <ESP_SYMBOL_L_PARENTHESIS> Expression(f1) <ESP_SYMBOL_R_PARENTHESIS>
    }
    catch(ParseException e){
        consumeUntil(g, e, "Element");
    }
}


//lexical analysis
public void parseLexical() : { }
{
    (
        nonsupportedBlockComment()
        | specialSymbol()
        | reservedWord()
        | constInt()
        | constReal()
        | constLiteral()
        | identifier()
        | nonsupportedSymbol()
        | nonsupportedConstLiteralSingle()
        | nonsupportedConstLiteralDouble()
        | nonsupportedIdentifier()
    )*
}

void specialSymbol() : { }
{
    (
        <ESP_SYMBOL_L_BRACKET>
        | <ESP_SYMBOL_R_BRACKET>
        | <ESP_SYMBOL_L_PARENTHESIS>
        | <ESP_SYMBOL_R_PARENTHESIS>
        | <ESP_SYMBOL_L_BRACE>
        | <ESP_SYMBOL_R_BRACE>
        | <ESP_SYMBOL_DOT>
        | <ESP_SYMBOL_COMA>
        | <ESP_SYMBOL_ASSIGNE>
        | <ESP_SYMBOL_PLUS>
        | <ESP_SYMBOL_MINUS>
        | <ESP_SYMBOL_STAR>
        | <ESP_SYMBOL_DIVISION_REAL>
        | <ESP_SYMBOL_POWER>
        | <ESP_SYMBOL_DIVISION_INT>
        | <ESP_SYMBOL_MOD>
        | <ESP_SYMBOL_EQUAL>
        | <ESP_SYMBOL_DIFFERENT>
        | <ESP_SYMBOL_GREATER>
        | <ESP_SYMBOL_LESSER>
        | <ESP_SYMBOL_GREATEREQUAL>
        | <ESP_SYMBOL_LESSERREQUAL>
        | <ESP_SYMBOL_AND>
        | <ESP_SYMBOL_OR>
        | <ESP_SYMBOL_NOT>
    )
    {    }
}

void reservedWord() : { }
{
     (
          <RESERVED_WORD_DO>
        | <RESERVED_WORD_THIS>
        | <RESERVED_WORD_BODY>
        | <RESERVED_WORD_DESCRIPTION>
        | <RESERVED_WORD_DECLARATION>
        | <RESERVED_WORD_TYPE>
        | <RESERVED_WORD_IS>
        | <RESERVED_WORD_CONSTANT>
        | <RESERVED_WORD_AND>
        | <RESERVED_WORD_VARIABLE>
        | <RESERVED_WORD_AS>
        | <RESERVED_WORD_INTEGER>
        | <RESERVED_WORD_REAL>
        | <RESERVED_WORD_STRING>
        | <RESERVED_WORD_LOGIC>
        | <RESERVED_WORD_DESIGNATE>
        | <RESERVED_WORD_READ>
        | <RESERVED_WORD_WRITE>
        | <RESERVED_WORD_ALL>
        | <RESERVED_WORD_REPEAT>
        | <RESERVED_WORD_AVALIATE>
        | <RESERVED_WORD_RESULT>
        | <RESERVED_WORD_TRUE>
        | <RESERVED_WORD_UNTRUE>
    )
    {
    }
}


void constInt() : { }
{
    <CONST_INT>
    {
    }
}

void constReal() : { }
{
    <CONST_REAL>
    {
    }
}

void constLiteral() : { }
{
    <CONST_LITERAL>
    {
    }
}

void identifier() : { }
{
    <IDENTIFIER>
    {
    }
}


void nonsupportedSymbol() : { lexErrorCount++; }
{
    <NONSUPPORTED_SYMBOL>
    {
        compile.printNotRecognizedToken(token.image, "Simbolo nao suportado", token.kind, token.beginLine, token.beginColumn);

    }
}

void nonsupportedConstLiteralSingle() : { lexErrorCount++; }
{
    <NONSUPPORTED_CONST_LITERAL_SINGLE>
    {
        compile.printNotRecognizedToken(token.image, "Constante literal nao suportada, faltando aspas simples", token.kind, token.beginLine, token.beginColumn);

    }
}

void nonsupportedConstLiteralDouble() : { lexErrorCount++; }
{
    <NONSUPPORTED_CONST_LITERAL_DOUBLE>
    {
        compile.printNotRecognizedToken(token.image, "Constante literal nao suportada. faltando aspas duplas", token.kind, token.beginLine, token.beginColumn);
;
    }
}

void nonsupportedBlockComment() : { lexErrorCount++; }
{
    <NONSUPPORTED_BLOCK_COMMENT>
    {
        compile.printNotRecognizedToken(token.image, "Nao contem o fechamento do bloco de comentario", token.kind, token.beginLine, token.beginColumn);

    }
}

void nonsupportedIdentifier() : { lexErrorCount++; }
{
    <NONSUPPORTED_IDENTIFIER>
    {
        compile.printNotRecognizedToken(token.image, "Identificador invalido", token.kind, token.beginLine, token.beginColumn);

    }
}