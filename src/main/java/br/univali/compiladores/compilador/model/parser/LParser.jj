options {
    STATIC = false;
    IGNORE_CASE = false;
    DEBUG_LOOKAHEAD = true;
}

PARSER_BEGIN(LParser)


package br.univali.compiladores.compilador.model.parser;
import br.univali.compiladores.compilador.model.LexicalAnalysis.LexicalAnalysis;
import br.univali.compiladores.compilador.model.SintaticAnalysis.SintaticAnalysis;
import br.univali.compiladores.compilador.model.recovery.First;
import br.univali.compiladores.compilador.model.recovery.RecoverySet;
import br.univali.compiladores.compilador.model.recovery.ParseEOFException;
import br.univali.compiladores.compilador.view.WindowER;

public class LParser
{
    private LexicalAnalysis lexicalAnalysis;
    private int lexErrorCount;
    private int synErrorCount;
    private SintaticAnalysis sintaticAnalysis;

    //para o AS
    private boolean debug_recovery = true;
    private boolean eof; // indica se encontramos o end of file
    private Token lastError = null;

    static public String im(int x)
    {
        int k;
        String s;
            s = tokenImage[x];
            k = s.lastIndexOf("\"");
            try{
                s =s.substring(1,k);
            }catch (StringIndexOutOfBoundsException e){
                System.err.println(e.getMessage());
            }
            return s;
    }

    void consumeUntil(RecoverySet g,ParseException e, String met) throws ParseEOFException, ParseException
    {
        Token tok;
        System.out.println("reading " + met);
        if (debug_recovery)
        {
            System.out.println();
            System.out.println("*** " + met + " ***");
            System.out.println("    Synchronizing Set: " + g);
        }
        if (g == null) throw e;
        tok = getToken(1);
        while (!eof)
        {
            if(g.contains(tok.kind))
                {
                    if(debug_recovery) System.out.println("    Found synchronizing token: " + im(tok.kind));
                    break;
                }
            if(debug_recovery)
                System.out.println("    Ignoring token: " + im(tok.kind));
            getNextToken();
            tok = getToken(1);
            if (tok.kind == EOF && ! g.contains(EOF))
                eof = true;
        }
        if(tok != lastError)
        {
         System.out.println(e.getMessage());
         synErrorCount++;
         lastError = tok;
        }


        //System.out.println(e.getMessage());
        //synErrorCount++;
        if (eof) throw  new ParseEOFException("EOF found prematurely");
    }


    public int getLexErrorCount() {
        return lexErrorCount;
    }

    public int getSynErrorCount() {
        return synErrorCount;
    }


    public void setLexicalAnalysis(WindowER gui){
        lexicalAnalysis = new LexicalAnalysis(gui);
    }
}



PARSER_END(LParser)


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <LINE_COMMENT:("#" (~["\n","\r"])* ("\n"|"\r"|"\r\n"))> /*LINE COMMENT*/
| <BLOCK_COMMENT: ("@" ((~["@"])*|"\n"|"\r"|"\r\n")* "@")>/*BLOCK COMMENT*/
}

TOKEN /*SPECIAL_SYMBOLS*/:
{
  <ESP_SYMBOL_L_BRACKET: "[">
| <ESP_SYMBOL_R_BRACKET: "]">
| <ESP_SYMBOL_L_PARENTHESIS: "(">
| <ESP_SYMBOL_R_PARENTHESIS: ")">
| <ESP_SYMBOL_L_BRACE: "{">
| <ESP_SYMBOL_R_BRACE: "}">
| <ESP_SYMBOL_DOT: ".">
| <ESP_SYMBOL_COMA: ",">
| <ESP_SYMBOL_ASSIGNE: "=">
| <ESP_SYMBOL_PLUS: "+">
| <ESP_SYMBOL_MINUS: "-">
| <ESP_SYMBOL_STAR: "*">
| <ESP_SYMBOL_DIVISION_REAL: "/">
| <ESP_SYMBOL_POWER: "**">
| <ESP_SYMBOL_DIVISION_INT: "%">
| <ESP_SYMBOL_MOD: "%%">
| <ESP_SYMBOL_EQUAL: "==">
| <ESP_SYMBOL_DIFFERENT: "!=">
| <ESP_SYMBOL_GREATER: ">>">
| <ESP_SYMBOL_LESSER: "<<">
| <ESP_SYMBOL_GREATEREQUAL: ">>=">
| <ESP_SYMBOL_LESSERREQUAL: "<<=">
| <ESP_SYMBOL_AND:  "&">
| <ESP_SYMBOL_OR:  "|">
| <ESP_SYMBOL_NOT: "!">
}

TOKEN /*RESERVED WORDS*/:
{
  <RESERVED_WORD_DO:("D"|"d")("O"|"o")>
| <RESERVED_WORD_THIS:("T"|"t")("H"|"h")("I"|"i")("S"|"s")>
| <RESERVED_WORD_BODY:("B"|"b")("O"|"o")("D"|"d")("Y"|"y")>
| <RESERVED_WORD_DESCRIPTION:("D"|"d")("E"|"e")("S"|"s")("C"|"c")("R"|"r")("I"|"i")("P"|"p")("T"|"t")("I"|"i")("O"|"o")("N"|"n")>
| <RESERVED_WORD_DECLARATION: ("D"|"d")("E"|"e")("C"|"c")("L"|"l")("A"|"a")("R"|"r")("A"|"a")("T"|"t")("I"|"i")("O"|"o")("N"|"n")>
| <RESERVED_WORD_TYPE:("T"|"t")("Y"|"y")("P"|"p")("E"|"e")>
| <RESERVED_WORD_IS:("I"|"i")("S"|"s")>
| <RESERVED_WORD_CONSTANT:("C"|"c")("O"|"o")("N"|"n")("S"|"s")("T"|"t")("A"|"a")("N"|"n")("T"|"t")>
| <RESERVED_WORD_AND:("A"|"a")("N"|"n")("D"|"d")>
| <RESERVED_WORD_VARIABLE:("V"|"v")("A"|"a")("R"|"r")("I"|"i")("A"|"a")("B"|"b")("L"|"l")("E"|"e")>
| <RESERVED_WORD_AS:("A"|"a")("S"|"s")>
| <RESERVED_WORD_INTEGER:("I"|"i")("N"|"n")("T"|"t")("E"|"e")("G"|"g")("E"|"e")("R"|"r")>
| <RESERVED_WORD_REAL:("R"|"r")("E"|"e")("A"|"a")("L"|"l")>
| <RESERVED_WORD_STRING:("S"|"s")("T"|"t")("R"|"r")("I"|"i")("N"|"n")("G"|"g")>
| <RESERVED_WORD_LOGIC:("L"|"l")("O"|"o")("G"|"g")("I"|"i")("C"|"c")>
| <RESERVED_WORD_ENUM:("E"|"e")("N"|"n")("U"|"u")("M"|"m")>
| <RESERVED_WORD_DESIGNATE:("D"|"d")("E"|"e")("S"|"s")("I"|"i")("G"|"g")("N"|"n")("A"|"a")("T"|"t")("E"|"e")>
| <RESERVED_WORD_READ:("R"|"r")("E"|"e")("A"|"a")("D"|"d")>
| <RESERVED_WORD_WRITE:("W"|"w")("R"|"r")("I"|"i")("T"|"t")("E"|"e")>
| <RESERVED_WORD_ALL:("A"|"a")("L"|"l")("L"|"l")>
| <RESERVED_WORD_REPEAT:("R"|"r")("E"|"e")("P"|"p")("E"|"e")("A"|"a")("T"|"t")>
| <RESERVED_WORD_AVALIATE:("A"|"a")("V"|"v")("A"|"a")("L"|"l")("I"|"i")("A"|"a")("T"|"t")("E"|"e")>
| <RESERVED_WORD_TRUE:("T"|"t")("R"|"r")("U"|"u")("E"|"e")>
| <RESERVED_WORD_UNTRUE:("U"|"u")("N"|"n")("T"|"t")("R"|"r")("U"|"u")("E"|"e")>
| <RESERVED_WORD_RESULT:("R"|"r")("E"|"e")("S"|"s")("U"|"u")("L"|"l")("T"|"t")>
}

TOKEN : { < #DIGIT : ["0"-"9"] > }
TOKEN : { < #LETTER : ["a"-"z","A"-"Z"] > }
TOKEN : { < #CAPSLETTER : ["A"-"Z"] > }
TOKEN : { < #LOWCAPSLETTER : ["a"-"z"] > }
TOKEN : { < #UNDER : ["_"] > }


TOKEN : /* INT */
{
  < CONST_INT: (<DIGIT>) | (<DIGIT>){2} | (<DIGIT>){3} >
}

TOKEN : /* REAL */
{
  < CONST_REAL: ((<DIGIT>) | (<DIGIT>){2} | (<DIGIT>){3} | (<DIGIT>){4} | (<DIGIT>){5}) "." ((<DIGIT>) | (<DIGIT>){2} | (<DIGIT>){3}) >
}

TOKEN : /* LITERAL */
{
  < CONST_LITERAL: ("\"" (~["\""])* "\"") | ("\'" (~["'"])* "\'") >
}


TOKEN : {
    /*<IDENTIFIER:(<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|(((<UNDER>)((<LETTER>)+(<DIGIT>){0,2}|(<DIGIT>){1,2}))|((<LETTER>)+(<DIGIT>){0,2}))*((<UNDER>)|(<LETTER>)+(<UNDER>)?)) >*/

    <IDENTIFIER:(<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*)>

}

TOKEN :
{
    < NONSUPPORTED_SYMBOL/* throws error for any token not listed bellow */:
    (~ ["a"-"z", "A"-"Z", "0"-"9", "@","\"", "'", "&",
        "(", ")", "[", "]", "{", "}", ",", ".", "=",
        ">", "<", "!", "+", "-", "*", "/", "%", "|",
        "$", "#", " ", "\t", "\n","\r", "\f"]
    )+ >
|   < NONSUPPORTED_CONST_LITERAL_SINGLE/* throws error for any open and not closed single quote */:
    ("'" (~ ["'"])*)
    >
|   < NONSUPPORTED_CONST_LITERAL_DOUBLE/* throws error for any open and not closed double quote */:
    ("\"" (~ ["\""])*)
    >
|   < NONSUPPORTED_BLOCK_COMMENT/* throws error for any open and not closed block comment  */:
    ("@" ((~["@"])*|"\n"|"\r"|"\r\n")*)
    >
|   < NONSUPPORTED_IDENTIFIER/* throws error for non valid identifiers  */:
    (
        /*starting with low caps letter*/
        ((<LOWCAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*))

        /*caps letter followed by 3 digits r2*/
        |((<CAPSLETTER>)((((<DIGIT>){2}(<DIGIT>)+((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*))

        /*caps letter followed by 3 digits r4*/
        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){2}(<DIGIT>)+((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*))

        /*caps letter followed by double_ or more*/
        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>){2}(<UNDER>)*|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*))

        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>){2}(<UNDER>)*))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*))

        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>){2}(<UNDER>)*))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*))

        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>){2}(<UNDER>)+(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*))

        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>){2}(<UNDER>)+)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*))

        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>){2}(<UNDER>)*(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*))

        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>){2}(<UNDER>)*|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*))

        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>){2}(<UNDER>)*))|((<LETTER>)+(<UNDER>)?))*))

        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>){2}(<UNDER>)*))*))

        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>){2}(<UNDER>)*|(<UNDER>){2}(<UNDER>)*))|((<LETTER>)+(<UNDER>){2}(<UNDER>)*))*|((<UNDER>){2}(<UNDER>)*(<LETTER>)+(<UNDER>){2}(<UNDER>)*)*|((<UNDER>){2}(<UNDER>)*(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>){2}(<UNDER>)*|(<UNDER>){2}(<UNDER>)*))|((<LETTER>)+(<UNDER>){2}(<UNDER>)*))*))

        /*caps letter finishing with numbers*/
        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*)(<DIGIT>)+)
    )
    >
}


//syntactical analysis
public void parseSyntactical() throws ParseEOFException : {}
{
//    Program()
  readProgram()
}

void readProgram() throws ParseEOFException:
{
RecoverySet g = new RecoverySet(EOF);
}
{
Program(g)<EOF>
}

void Program(RecoverySet g) throws ParseEOFException :
{
RecoverySet f1 = new RecoverySet(ESP_SYMBOL_R_BRACKET).union(g),
            f2 = new RecoverySet(RESERVED_WORD_BODY).union(f1),
            f3 = First.DeclarationConstantsAndVariables.union(f2);
            }
{
try{
<RESERVED_WORD_DO> <RESERVED_WORD_THIS> <IDENTIFIER> <ESP_SYMBOL_L_BRACKET> <ESP_SYMBOL_R_BRACKET>
 DeclarationEnumeratedType(f3) DeclarationConstantsAndVariables(f2) <RESERVED_WORD_BODY> <ESP_SYMBOL_L_BRACKET>
   CommandList(f1) <ESP_SYMBOL_R_BRACKET> Description(g)
}
catch (ParseException e){
consumeUntil(g, e, "program declaration");
}
}

//REVER MENSAGENS PARA O CONSUME UNTILL A PARTIR DAQUI
//bloco description
void Description(RecoverySet g) throws ParseEOFException:
{}
{
try{
[<RESERVED_WORD_DESCRIPTION> <CONST_LITERAL>]
}
catch(ParseException e){
consumeUntil(g, e, "description statement");
}
}


//DeclarationEnumeratedType block
void DeclarationEnumeratedType(RecoverySet g) throws ParseEOFException:
{
 RecoverySet f1 = new RecoverySet(ESP_SYMBOL_R_BRACKET);
}
{
try{
[LOOKAHEAD (2) <RESERVED_WORD_DECLARATION> <RESERVED_WORD_TYPE> <ESP_SYMBOL_L_BRACKET> IdentifierEnumTypeDeclarationList(f1) <ESP_SYMBOL_R_BRACKET>]
}
catch(ParseException e){
consumeUntil(g, e, "enumerated type declaration");
}
}

void IdentifierEnumTypeDeclarationList(RecoverySet g) throws ParseEOFException:
{
RecoverySet f1 = new RecoverySet(ESP_SYMBOL_DOT);
}
{
try{
(<IDENTIFIER> <RESERVED_WORD_IS> IdentifierList(f1) <ESP_SYMBOL_DOT>)+
}
catch(ParseException e){
consumeUntil(g, e, "Identifier Enum Type Declaration List");
}
}

void IdentifierList(RecoverySet g) throws ParseEOFException:
{
}
{
try{
<IDENTIFIER> ((<ESP_SYMBOL_COMA> <IDENTIFIER>)*)
}
catch(ParseException e){
consumeUntil(g, e, "identifier list");
}
}

void DeclarationConstantsAndVariables(RecoverySet g) throws ParseEOFException:
{
 RecoverySet f1 = new RecoverySet(ESP_SYMBOL_R_BRACKET);
}
{
try{
[<RESERVED_WORD_DECLARATION> <RESERVED_WORD_CONSTANT> <RESERVED_WORD_AND> <RESERVED_WORD_VARIABLE>
    <ESP_SYMBOL_L_BRACKET> OrderConstantsAndVariables(f1) <ESP_SYMBOL_R_BRACKET>]
}
catch(ParseException e){
consumeUntil(g, e, "constants and varibles");
}
}
void OrderConstantsAndVariables(RecoverySet g) throws ParseEOFException:
{}
{
try{
<RESERVED_WORD_AS> ConstantAndVariablesInitiation(g)
}
catch(ParseException e){
consumeUntil(g, e, "order constant and variables");
}
}

void ConstantAndVariablesInitiation(RecoverySet g) throws ParseEOFException:
{
 RecoverySet f1 = First.AsVariables.union(g),
             f2 = First.AsConstants.union(g);
}
{
try{
<RESERVED_WORD_CONSTANT> AsConstants(f1) [(<RESERVED_WORD_AS> <RESERVED_WORD_VARIABLE>  AsVariables(g))]
| <RESERVED_WORD_VARIABLE> AsVariables(f2) [(<RESERVED_WORD_AS> <RESERVED_WORD_CONSTANT> AsConstants(g))]
}
catch(ParseException e){
consumeUntil(g, e, "constants and varibles");
}
}

// Constants Declaration sub block
void AsConstants(RecoverySet g) throws ParseEOFException:
{
}
{
try{
//[<RESERVED_WORD_CONSTANT> ConstantsList(g)]
[ConstantsList(g)]
}
catch(ParseException e){
consumeUntil(g, e, "Constants");
}
}

void ConstantsList(RecoverySet g) throws ParseEOFException:
{
 RecoverySet f1 = new RecoverySet(RESERVED_WORD_IS),
             f2 = new RecoverySet(ESP_SYMBOL_DOT);
}
{
try{
//IdentifiersList is part of DeclarationEnumeratedType block
(IdentifierList(f1) <RESERVED_WORD_IS> ConstTypeValueCombo(f2)<ESP_SYMBOL_DOT>)+
}
catch(ParseException e){
consumeUntil(g, e, "constants and varibles");
}
}

void ConstTypeValueCombo(RecoverySet g) throws ParseEOFException:
{
}
{
try{
<RESERVED_WORD_INTEGER> <ESP_SYMBOL_ASSIGNE> <CONST_INT>
|<RESERVED_WORD_REAL> <ESP_SYMBOL_ASSIGNE> <CONST_REAL>
|<RESERVED_WORD_STRING> <ESP_SYMBOL_ASSIGNE> <CONST_LITERAL>
|<RESERVED_WORD_LOGIC> <ESP_SYMBOL_ASSIGNE> TypeAndValueLogicConstants(g)
}
catch(ParseException e){
consumeUntil(g, e, "constants and varibles");
}
}

void TypeAndValueLogicConstants(RecoverySet g) throws ParseEOFException:
{}
{
try{
<RESERVED_WORD_TRUE>
| <RESERVED_WORD_UNTRUE>
}
catch(ParseException e){
consumeUntil(g, e, "logical operators");
}
}

//Variables declaration sub block
void AsVariables(RecoverySet g) throws ParseEOFException:
 {
 }
 {
 try{
 //[<RESERVED_WORD_VARIABLE> VariablesList(g)]
 [VariablesList(g)]
 }
 catch(ParseException e){
 consumeUntil(g, e, "Varibles");
 }
 }

 void VariablesList(RecoverySet g) throws ParseEOFException:
 {
  RecoverySet f1 = new RecoverySet(RESERVED_WORD_IS),
              f2 = new RecoverySet(ESP_SYMBOL_DOT);
 }
 {
 try{
 (IdentifierVariablesList(f1) <RESERVED_WORD_IS> VariablesTypes(f2) <ESP_SYMBOL_DOT>)+
 }
 catch(ParseException e){
 consumeUntil(g, e, "List Of Variable Identifiers");
 }
 }

 void IdentifierVariablesList(RecoverySet g) throws ParseEOFException:
 {
 RecoverySet f1 = First.Index.union(g);
 }
 {
 try{
 <IDENTIFIER> Index(f1) ((<ESP_SYMBOL_COMA> <IDENTIFIER> Index(f1))*)
 }
 catch(ParseException e){
 consumeUntil(g, e, "Identifier Variables List");
 }
 }

 void Index(RecoverySet g) throws ParseEOFException:
 {}
 {
 try{
 [<ESP_SYMBOL_L_BRACE> <CONST_INT> <ESP_SYMBOL_R_BRACE>]
 }
 catch(ParseException e){
 consumeUntil(g, e, "index");
 }
 }

 void VariablesTypes(RecoverySet g) throws ParseEOFException:
 {
 }
 {
 try{
 <RESERVED_WORD_INTEGER>
 |<RESERVED_WORD_REAL>
 |<RESERVED_WORD_STRING>
 |<RESERVED_WORD_LOGIC>
 | DeclarationEnumeratedType(g)
 }
 catch(ParseException e){
 consumeUntil(g, e, "Variables Types");
 }
 }
//====================================================================================
//Assignmeent block
void CmdAssignment(RecoverySet g) throws ParseEOFException:
{
 RecoverySet f1 = new RecoverySet(RESERVED_WORD_AS),
             f2 = new RecoverySet(ESP_SYMBOL_DOT);
}
{
try{
<RESERVED_WORD_DESIGNATE> <RESERVED_WORD_THIS> IdentifierVariablesList(f1) <RESERVED_WORD_AS>
    Expression(f2) <ESP_SYMBOL_DOT>
}
catch(ParseException e){
 consumeUntil(g, e, "Command Assignment declaration");
}
}

void Expression(RecoverySet g) throws ParseEOFException:
{
RecoverySet f1 = First.ExpressionL.union(g);
}
{
try{
ArithmeticOrLogicalExpression(f1) ExpressionL(g)
}
catch(ParseException e){
consumeUntil(g, e, "expression");
}
}

void ExpressionL(RecoverySet g) throws ParseEOFException:
{}
{
try{
[(<ESP_SYMBOL_EQUAL>  ArithmeticOrLogicalExpression(g)
| <ESP_SYMBOL_DIFFERENT> ArithmeticOrLogicalExpression(g)
| <ESP_SYMBOL_GREATER>  ArithmeticOrLogicalExpression(g)
| <ESP_SYMBOL_LESSER> ArithmeticOrLogicalExpression(g)
| <ESP_SYMBOL_LESSERREQUAL> ArithmeticOrLogicalExpression(g)
| <ESP_SYMBOL_GREATEREQUAL> ArithmeticOrLogicalExpression(g))]
}
catch(ParseException e){
consumeUntil(g, e, "comparative operators");
}
}

void ArithmeticOrLogicalExpression(RecoverySet g) throws ParseEOFException:
{
RecoverySet f1 = First.LowestPriority.union(g);
}
{
try{
SecondTerm(f1) LowestPriority(g)
}
catch(ParseException e){
consumeUntil(g, e, "arithmetical or logical expression");
}
}

void LowestPriority(RecoverySet g) throws ParseEOFException:
{
 RecoverySet f1 = First.LowestPriority.union(g);
}
{
try{
[(<ESP_SYMBOL_PLUS> SecondTerm(f1) LowestPriority(g)
| <ESP_SYMBOL_MINUS> SecondTerm(f1) LowestPriority(g)
| <ESP_SYMBOL_OR> SecondTerm(f1) LowestPriority(g))]
}
catch(ParseException e){
consumeUntil(g, e, "low priority expression values");
}
}

void SecondTerm(RecoverySet g) throws ParseEOFException:
{
 RecoverySet f1 = First.MediumPriority.union(g);
}
{
try{
FirstTerm(f1) MediumPriority(g)
}
catch(ParseException e){
consumeUntil(g, e, "expression second term");
}
}

void MediumPriority (RecoverySet g) throws ParseEOFException:
{
 RecoverySet f1 = First.MediumPriority.union(g);
}
{
try{
[(<ESP_SYMBOL_STAR> FirstTerm(f1) MediumPriority(g)
| <ESP_SYMBOL_DIVISION_REAL> FirstTerm(f1) MediumPriority(g)
| <ESP_SYMBOL_DIVISION_INT> FirstTerm(f1) MediumPriority(g)
| <ESP_SYMBOL_MOD> FirstTerm(f1) MediumPriority(g)
| <ESP_SYMBOL_AND> FirstTerm(f1) MediumPriority(g))]
}
catch(ParseException e){
consumeUntil(g, e, "medium priority expression values");
}
}

void FirstTerm(RecoverySet g) throws ParseEOFException:
{
 RecoverySet f1 = First.HighestPriority.union(g);
}
{
try{
Element(f1) HighestPriority(g)
}
catch(ParseException e){
consumeUntil(g, e, "expression first term");
}
}

void HighestPriority(RecoverySet g) throws ParseEOFException:
{
 RecoverySet f1 = First.HighestPriority.union(g);
}
{
try{
[(<ESP_SYMBOL_POWER> Element(f1) HighestPriority(g))]
}
catch(ParseException e){
consumeUntil(g, e, "high priority expression values");
}
}

void Element(RecoverySet g) throws ParseEOFException:
{
 RecoverySet f1 = new RecoverySet(ESP_SYMBOL_R_PARENTHESIS);
 }
{
try{
<IDENTIFIER> Index(g)
| <CONST_INT>
| <CONST_REAL>
| <CONST_LITERAL>
| <RESERVED_WORD_TRUE>
| <RESERVED_WORD_UNTRUE>
| <ESP_SYMBOL_L_PARENTHESIS> Expression(f1) <ESP_SYMBOL_R_PARENTHESIS>
| <ESP_SYMBOL_DIFFERENT> <ESP_SYMBOL_L_PARENTHESIS> Expression(f1) <ESP_SYMBOL_R_PARENTHESIS>
}
catch(ParseException e){
consumeUntil(g, e, "constant identifier");
}
}
//index is located at Variables declaration sub block/
//====================================================================================
//Data input block
void CmdDataInput(RecoverySet g) throws ParseEOFException:
{
 RecoverySet f1 = new RecoverySet(ESP_SYMBOL_R_BRACKET);
}
{
try{
<RESERVED_WORD_READ> <RESERVED_WORD_THIS> <ESP_SYMBOL_L_BRACKET>  IdentifierVariablesList(f1)
<ESP_SYMBOL_R_BRACKET> <ESP_SYMBOL_DOT>
}
catch(ParseException e){
consumeUntil(g, e, "Command Input Data Declaration");
}
}

//====================================================================================
//Data output block
void CmdDataOutput(RecoverySet g) throws ParseEOFException:
{}
{
try{
<RESERVED_WORD_WRITE> (This(g) | AllThis(g))
}
catch(ParseException e){
consumeUntil(g, e, "Command Output Data Declaration");
}
}

void This(RecoverySet g) throws ParseEOFException:
{
RecoverySet f1 = new RecoverySet(ESP_SYMBOL_R_BRACKET);
}
{
try{
<RESERVED_WORD_THIS> <ESP_SYMBOL_L_BRACKET> IdentifiersAndOrConstantsList(f1) <ESP_SYMBOL_R_BRACKET> <ESP_SYMBOL_DOT>
}
catch(ParseException e){
consumeUntil(g, e, "output this");
}
}

void AllThis(RecoverySet g) throws ParseEOFException:
{}
{
try{
<RESERVED_WORD_ALL> This(g)
}
catch(ParseException e){
consumeUntil(g, e, "output all this");
}
}

void IdentifiersAndOrConstantsList(RecoverySet g) throws ParseEOFException:
{
 RecoverySet f1 = First.OutPutConstants.union(g);

}
{
try{
(LOOKAHEAD(3) IdentifierVariablesList(g) | IdentifierList(g))
| OutPutConstants(f1) ((<ESP_SYMBOL_COMA> OutPutConstants(f1))*)
}
catch(ParseException e){
consumeUntil(g, e, "output");
}
}

void OutPutConstants(RecoverySet g) throws ParseEOFException:
{
}
{
try{
<CONST_LITERAL> | <CONST_INT> | <CONST_REAL>
}
catch(ParseException e){
consumeUntil(g, e, "output");
}
}
//====================================================================================
//Selection command block
void CmdSelection (RecoverySet g) throws ParseEOFException:
{
RecoverySet f1 = new RecoverySet(ESP_SYMBOL_DOT),
            f2 = First.Evaluate.union(f1);
}
{
try{
<RESERVED_WORD_AVALIATE> <RESERVED_WORD_THIS> Expression(f2) Evaluate(f1) <ESP_SYMBOL_DOT>
}
catch(ParseException e){
consumeUntil(g, e, "Command Select Declaration");
}
}

void Evaluate (RecoverySet g) throws ParseEOFException:
{
 RecoverySet f1 = First.EvaluateUntrue.union(g),
 			f2 = First.EvaluateTrue.union(g);
}
{
try{
EvaluateTrue(f1) [EvaluateUntrue(g)] | EvaluateUntrue(f2) [EvaluateTrue(g)]
}
catch(ParseException e){
consumeUntil(g, e, "Evaluate");
}
}

void EvaluateTrue(RecoverySet g) throws ParseEOFException :
{
RecoverySet f1 = new RecoverySet(ESP_SYMBOL_R_BRACKET);
}
{
try {
<RESERVED_WORD_TRUE> <RESERVED_WORD_RESULT> <ESP_SYMBOL_L_BRACKET> CommandList(f1)
<ESP_SYMBOL_R_BRACKET>
} catch (ParseException e) {
consumeUntil(g, e, "selection statement: true");
}
}

void EvaluateUntrue(RecoverySet g) throws ParseEOFException :
{
RecoverySet f1 = new RecoverySet(ESP_SYMBOL_R_BRACKET);
}
{
try {
<RESERVED_WORD_UNTRUE> <RESERVED_WORD_RESULT> <ESP_SYMBOL_L_BRACKET> CommandList(f1)
<ESP_SYMBOL_R_BRACKET>
} catch (ParseException e) {
consumeUntil(g, e, "selection statement: untrue");
}
}

void CommandList(RecoverySet g) throws ParseEOFException :
{
 RecoverySet f1 = First.Command.union(g);
}
{
try {
(Command(f1))+
} catch (ParseException e) {
consumeUntil(g, e, "command list");
}
}

void Command(RecoverySet g) throws ParseEOFException:
{}
{
try{
CmdAssignment(g)
| CmdDataInput(g)
| CmdDataOutput(g)
| CmdSelection(g)
| CmdRepetition(g)
}
catch(ParseException e){
consumeUntil(g, e, "command");
}
}

void CmdRepetition(RecoverySet g) throws ParseEOFException:
{
RecoverySet f2 = new RecoverySet(ESP_SYMBOL_DOT);
RecoverySet f1 = First.EvaluateRep.union(f2);

}
{
try{
//<RESERVED_WORD_REPEAT> <RESERVED_WORD_THIS> Expression(f1) <ESP_SYMBOL_L_BRACKET> CommandList(f2) <ESP_SYMBOL_R_BRACKET>
//    <ESP_SYMBOL_DOT>
<RESERVED_WORD_REPEAT> <RESERVED_WORD_THIS> Expression(f1) EvaluateRep(f2)<ESP_SYMBOL_DOT>
}
catch(ParseException e){
consumeUntil(g, e, "Command Repetition Declaration");
}
}

void EvaluateRep (RecoverySet g) throws ParseEOFException:
{
}
{
try{
(LOOKAHEAD(2) EvaluateRepTrue(g) | EvaluateRepUntrue(g))
}
catch(ParseException e){
consumeUntil(g, e, "Evaluate Repetition Condition");
}
}

void EvaluateRepTrue(RecoverySet g) throws ParseEOFException :
{
RecoverySet f1 = new RecoverySet(ESP_SYMBOL_R_BRACKET);
}
{
try {
<ESP_SYMBOL_L_BRACKET> CommandList(f1)<ESP_SYMBOL_R_BRACKET>
} catch (ParseException e) {
consumeUntil(g, e, "repetition evaluation: condition satisfied");
}
}

void EvaluateRepUntrue(RecoverySet g) throws ParseEOFException :
{
RecoverySet f1 = new RecoverySet(ESP_SYMBOL_R_BRACKET);
}
{
try {
<ESP_SYMBOL_L_BRACKET><ESP_SYMBOL_R_BRACKET>
} catch (ParseException e) {
consumeUntil(g, e, "repetition evaluation: condition not satisfied");
}
}


//lexical analysis
public void parseLexical() : { }
{
    (
        nonsupportedBlockComment()
        | specialSymbol()
        | reservedWord()
        | constInt()
        | constReal()
        | constLiteral()
        | identifier()
        | nonsupportedSymbol()
        | nonsupportedConstLiteralSingle()
        | nonsupportedConstLiteralDouble()
        | nonsupportedIdentifier()
    )*
}

void specialSymbol() : { }
{
    (
        <ESP_SYMBOL_L_BRACKET>
        | <ESP_SYMBOL_R_BRACKET>
        | <ESP_SYMBOL_L_PARENTHESIS>
        | <ESP_SYMBOL_R_PARENTHESIS>
        | <ESP_SYMBOL_L_BRACE>
        | <ESP_SYMBOL_R_BRACE>
        | <ESP_SYMBOL_DOT>
        | <ESP_SYMBOL_COMA>
        | <ESP_SYMBOL_ASSIGNE>
        | <ESP_SYMBOL_PLUS>
        | <ESP_SYMBOL_MINUS>
        | <ESP_SYMBOL_STAR>
        | <ESP_SYMBOL_DIVISION_REAL>
        | <ESP_SYMBOL_POWER>
        | <ESP_SYMBOL_DIVISION_INT>
        | <ESP_SYMBOL_MOD>
        | <ESP_SYMBOL_EQUAL>
        | <ESP_SYMBOL_DIFFERENT>
        | <ESP_SYMBOL_GREATER>
        | <ESP_SYMBOL_LESSER>
        | <ESP_SYMBOL_GREATEREQUAL>
        | <ESP_SYMBOL_LESSERREQUAL>
        | <ESP_SYMBOL_AND>
        | <ESP_SYMBOL_OR>
        | <ESP_SYMBOL_NOT>
    )
    {
        lexicalAnalysis.printRecognizedToken(token.image, "Simbolo Especial", token.kind, token.beginLine, token.beginColumn);
    }
}

void reservedWord() : { }
{
     (
          <RESERVED_WORD_DO>
        | <RESERVED_WORD_THIS>
        | <RESERVED_WORD_BODY>
        | <RESERVED_WORD_DESCRIPTION>
        | <RESERVED_WORD_DECLARATION>
        | <RESERVED_WORD_TYPE>
        | <RESERVED_WORD_IS>
        | <RESERVED_WORD_CONSTANT>
        | <RESERVED_WORD_AND>
        | <RESERVED_WORD_VARIABLE>
        | <RESERVED_WORD_AS>
        | <RESERVED_WORD_INTEGER>
        | <RESERVED_WORD_REAL>
        | <RESERVED_WORD_STRING>
        | <RESERVED_WORD_LOGIC>
        | <RESERVED_WORD_DESIGNATE>
        | <RESERVED_WORD_READ>
        | <RESERVED_WORD_WRITE>
        | <RESERVED_WORD_ALL>
        | <RESERVED_WORD_REPEAT>
        | <RESERVED_WORD_AVALIATE>
        | <RESERVED_WORD_TRUE>
        | <RESERVED_WORD_UNTRUE>
    )
    {
        lexicalAnalysis.printRecognizedToken(token.image, "Palavra Reservada", token.kind, token.beginLine, token.beginColumn);

    }
}


void constInt() : { }
{
    <CONST_INT>
    {
        lexicalAnalysis.printRecognizedToken(token.image, "Constante Inteira", token.kind, token.beginLine, token.beginColumn);

    }
}

void constReal() : { }
{
    <CONST_REAL>
    {
        lexicalAnalysis.printRecognizedToken(token.image, "Constante Real", token.kind, token.beginLine, token.beginColumn);

    }
}

void constLiteral() : { }
{
    <CONST_LITERAL>
    {
        lexicalAnalysis.printRecognizedToken(token.image, "Constante Literal", token.kind, token.beginLine, token.beginColumn);

    }
}

void identifier() : { }
{
    <IDENTIFIER>
    {
        lexicalAnalysis.printRecognizedToken(token.image, "Identificador", token.kind, token.beginLine, token.beginColumn);

    }
}


void nonsupportedSymbol() : { lexErrorCount++; }
{
    <NONSUPPORTED_SYMBOL>
    {
        lexicalAnalysis.printNotRecognizedToken(token.image, "Simbolo nao suportado", token.kind, token.beginLine, token.beginColumn);

    }
}

void nonsupportedConstLiteralSingle() : { lexErrorCount++; }
{
    <NONSUPPORTED_CONST_LITERAL_SINGLE>
    {
        lexicalAnalysis.printNotRecognizedToken(token.image, "Constante literal nao suportada, faltando aspas simples", token.kind, token.beginLine, token.beginColumn);

    }
}

void nonsupportedConstLiteralDouble() : { lexErrorCount++; }
{
    <NONSUPPORTED_CONST_LITERAL_DOUBLE>
    {
        lexicalAnalysis.printNotRecognizedToken(token.image, "Constante literal nao suportada. faltando aspas duplas", token.kind, token.beginLine, token.beginColumn);
;
    }
}

void nonsupportedBlockComment() : { lexErrorCount++; }
{
    <NONSUPPORTED_BLOCK_COMMENT>
    {
        lexicalAnalysis.printNotRecognizedToken(token.image, "Nao contem o fechamento do bloco de comentario", token.kind, token.beginLine, token.beginColumn);

    }
}

void nonsupportedIdentifier() : { lexErrorCount++; }
{
    <NONSUPPORTED_IDENTIFIER>
    {
        lexicalAnalysis.printNotRecognizedToken(token.image, "Identificador invalido", token.kind, token.beginLine, token.beginColumn);

    }
}