options {
    STATIC = false;
    IGNORE_CASE = false;
}

PARSER_BEGIN(LParser)

package br.univali.compiladores.compilador.model.parser;

import br.univali.compiladores.compilador.model.LexicalAnalysis.LexicalAnalysis;
import br.univali.compiladores.compilador.view.WindowER;

public class LParser {
    //errorCount mudou para lexErrorcount
    //getErrorCount mudou para getLexErrorCount
    //adicionado synErrorcount
    //adicionado synLexErrorCount

    private LexicalAnalysis lexicalAnalysis;
    private int lexErrorCount;
    private int synErrorCount;
    
    public int getLexErrorCount() {
        return lexErrorCount;
    }

    public int getSynErrorCount() {
        return synErrorCount;
    }


    public void setLexicalAnalysis(WindowER gui){
        lexicalAnalysis = new LexicalAnalysis(gui);
    }
}

PARSER_END(LParser)


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <LINE_COMMENT:("#" (~["\n","\r"])* ("\n"|"\r"|"\r\n"))> /*LINE COMMENT*/
| <BLOCK_COMMENT: ("@" ((~["@"])*|"\n"|"\r"|"\r\n")* "@")>/*BLOCK COMMENT*/
}

TOKEN /*SPECIAL_SYMBOLS*/:
{
  <ESP_SYMBOL_L_BRACKET: "[">  
| <ESP_SYMBOL_R_BRACKET: "]"> 
| <ESP_SYMBOL_L_PARENTHESIS: "("> 
| <ESP_SYMBOL_R_PARENTHESIS: ")"> 
| <ESP_SYMBOL_L_BRACE: "{"> 
| <ESP_SYMBOL_R_BRACE: "}"> 
| <ESP_SYMBOL_DOT: "."> 
| <ESP_SYMBOL_COMA: ","> 
| <ESP_SYMBOL_ASSIGNE: "="> 
| <ESP_SYMBOL_PLUS: "+"> 
| <ESP_SYMBOL_MINUS: "-"> 
| <ESP_SYMBOL_STAR: "*"> 
| <ESP_SYMBOL_DIVISION_REAL: "/"> 
| <ESP_SYMBOL_POWER: "**"> 
| <ESP_SYMBOL_DIVISION_INT: "%"> 
| <ESP_SYMBOL_MOD: "%%"> 
| <ESP_SYMBOL_EQUAL: "=="> 
| <ESP_SYMBOL_DIFFERENT: "!="> 
| <ESP_SYMBOL_GREATER: ">>"> 
| <ESP_SYMBOL_LESSER: "<<"> 
| <ESP_SYMBOL_GREATEREQUAL: ">>="> 
| <ESP_SYMBOL_LESSERREQUAL: "<<="> 
| <ESP_SYMBOL_AND:  "&"> 
| <ESP_SYMBOL_OR:  "|"> 
| <ESP_SYMBOL_NOT: "!">
}

TOKEN /*RESERVED WORDS*/: 
{
  <RESERVED_WORD_DO:("D"|"d")("O"|"o")>
| <RESERVED_WORD_THIS:("T"|"t")("H"|"h")("I"|"i")("S"|"s")>
| <RESERVED_WORD_BODY:("B"|"b")("O"|"o")("D"|"d")("Y"|"y")>
| <RESERVED_WORD_DESCRIPTION:("D"|"d")("E"|"e")("S"|"s")("C"|"c")("R"|"r")("I"|"i")("P"|"p")("T"|"t")("I"|"i")("O"|"o")("N"|"n")>
| <RESERVED_WORD_DECLARATION: ("D"|"d")("E"|"e")("C"|"c")("L"|"l")("A"|"a")("R"|"r")("A"|"a")("T"|"t")("I"|"i")("O"|"o")("N"|"n")>
| <RESERVED_WORD_TYPE:("T"|"t")("Y"|"y")("P"|"p")("E"|"e")>
| <RESERVED_WORD_IS:("I"|"i")("S"|"s")>
| <RESERVED_WORD_CONSTANT:("C"|"c")("O"|"o")("N"|"n")("S"|"s")("T"|"t")("A"|"a")("N"|"n")("T"|"t")>
| <RESERVED_WORD_AND:("A"|"a")("N"|"n")("D"|"d")>
| <RESERVED_WORD_VARIABLE:("V"|"v")("A"|"a")("R"|"r")("I"|"i")("A"|"a")("B"|"b")("L"|"l")("E"|"e")>
| <RESERVED_WORD_AS:("A"|"a")("S"|"s")>
| <RESERVED_WORD_INTEGER:("I"|"i")("N"|"n")("T"|"t")("E"|"e")("G"|"g")("E"|"e")("R"|"r")>
| <RESERVED_WORD_REAL:("R"|"r")("E"|"e")("A"|"a")("L"|"l")>
| <RESERVED_WORD_STRING:("S"|"s")("T"|"t")("R"|"r")("I"|"i")("N"|"n")("G"|"g")>
| <RESERVED_WORD_LOGIC:("L"|"l")("O"|"o")("G"|"g")("I"|"i")("C"|"c")>
| <RESERVED_WORD_ENUM:("E"|"e")("N"|"n")("U"|"u")("M"|"m")>
| <RESERVED_WORD_DESIGNATE:("D"|"d")("E"|"e")("S"|"s")("I"|"i")("G"|"g")("N"|"n")("A"|"a")("T"|"t")("E"|"e")>
| <RESERVED_WORD_READ:("R"|"r")("E"|"e")("A"|"a")("D"|"d")>
| <RESERVED_WORD_WRITE:("W"|"w")("R"|"r")("I"|"i")("T"|"t")("E"|"e")>
| <RESERVED_WORD_ALL:("A"|"a")("L"|"l")("L"|"l")>
| <RESERVED_WORD_REPEAT:("R"|"r")("E"|"e")("P"|"p")("E"|"e")("A"|"a")("T"|"t")>
| <RESERVED_WORD_AVALIATE:("A"|"a")("V"|"v")("A"|"a")("L"|"l")("I"|"i")("A"|"a")("T"|"t")("E"|"e")>
| <RESERVED_WORD_TRUE:("T"|"t")("R"|"r")("U"|"u")("E"|"e")>
| <RESERVED_WORD_UNTRUE:("U"|"u")("N"|"n")("T"|"t")("R"|"r")("U"|"u")("E"|"e")>
| <RESERVED_WORD_RESULT:("R"|"r")("E"|"e")("S"|"s")("U"|"u")("L"|"l")("T"|"t")>
}

TOKEN : { < #DIGIT : ["0"-"9"] > }
TOKEN : { < #LETTER : ["a"-"z","A"-"Z"] > }
TOKEN : { < #CAPSLETTER : ["A"-"Z"] > }
TOKEN : { < #LOWCAPSLETTER : ["a"-"z"] > }
TOKEN : { < #UNDER : ["_"] > }


TOKEN : /* INT */
{
  < CONST_INT: (<DIGIT>) | (<DIGIT>){2} | (<DIGIT>){3} >
}

TOKEN : /* REAL */
{
  < CONST_REAL: ((<DIGIT>) | (<DIGIT>){2} | (<DIGIT>){3} | (<DIGIT>){4} | (<DIGIT>){5}) "." ((<DIGIT>) | (<DIGIT>){2} | (<DIGIT>){3}) >
}

TOKEN : /* LITERAL */
{
  < CONST_LITERAL: ("\"" (~["\""])* "\"") | ("\'" (~["'"])* "\'") >
}

TOKEN : {
    /*<IDENTIFIER:(<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|(((<UNDER>)((<LETTER>)+(<DIGIT>){0,2}|(<DIGIT>){1,2}))|((<LETTER>)+(<DIGIT>){0,2}))*((<UNDER>)|(<LETTER>)+(<UNDER>)?)) >*/

    <IDENTIFIER:(<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*)>

}

TOKEN :
{
    < NONSUPPORTED_SYMBOL/* throws error for any token not listed bellow */:
    (~ ["a"-"z", "A"-"Z", "0"-"9", "@","\"", "'", "&",
        "(", ")", "[", "]", "{", "}", ",", ".", "=",
        ">", "<", "!", "+", "-", "*", "/", "%", "|",
        "$", "#", " ", "\t", "\n","\r", "\f"]
    )+ >
|   < NONSUPPORTED_CONST_LITERAL_SINGLE/* throws error for any open and not closed single quote */:
    ("'" (~ ["'"])*)
    >
|   < NONSUPPORTED_CONST_LITERAL_DOUBLE/* throws error for any open and not closed double quote */:
    ("\"" (~ ["\""])*)
    >
|   < NONSUPPORTED_BLOCK_COMMENT/* throws error for any open and not closed block comment  */:
    ("@" ((~["@"])*|"\n"|"\r"|"\r\n")*)
    >
|   < NONSUPPORTED_IDENTIFIER/* throws error for non valid identifiers  */:
    (
        /*starting with low caps letter*/
        ((<LOWCAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*))

        /*caps letter followed by 3 digits r2*/
        |((<CAPSLETTER>)((((<DIGIT>){2}(<DIGIT>)+((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*))

        /*caps letter followed by 3 digits r4*/
        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){2}(<DIGIT>)+((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*))

        /*caps letter followed by double_ or more*/
        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>){2}(<UNDER>)*|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*))

        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>){2}(<UNDER>)*))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*))

        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>){2}(<UNDER>)*))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*))
        
        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>){2}(<UNDER>)+(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*))

        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>){2}(<UNDER>)+)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*))

        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>){2}(<UNDER>)*(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*))

        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>){2}(<UNDER>)*|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*))

        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>){2}(<UNDER>)*))|((<LETTER>)+(<UNDER>)?))*))

        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>){2}(<UNDER>)*))*))

        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>){2}(<UNDER>)*|(<UNDER>){2}(<UNDER>)*))|((<LETTER>)+(<UNDER>){2}(<UNDER>)*))*|((<UNDER>){2}(<UNDER>)*(<LETTER>)+(<UNDER>){2}(<UNDER>)*)*|((<UNDER>){2}(<UNDER>)*(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>){2}(<UNDER>)*|(<UNDER>){2}(<UNDER>)*))|((<LETTER>)+(<UNDER>){2}(<UNDER>)*))*))

        /*caps letter finishing with numbers*/
        |((<CAPSLETTER>)((((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*|((<UNDER>)(<LETTER>)+(<UNDER>)?)*|((<UNDER>)?(<LETTER>)*)(((<DIGIT>){1,2}((<LETTER>)+(<UNDER>)?|(<UNDER>)))|((<LETTER>)+(<UNDER>)?))*)(<DIGIT>)+)
    )
    >
}


//syntactical analysis
public void parseSyntactical() : {}
{
    Program() 
} 


void Program() :
{}
{
<RESERVED_WORD_DO> <RESERVED_WORD_THIS> <IDENTIFIER> <ESP_SYMBOL_L_BRACKET> <ESP_SYMBOL_R_BRACKET> EnumeratedType() ConstantsAndVariables() <RESERVED_WORD_BODY> <ESP_SYMBOL_L_BRACKET>  CommandList() <ESP_SYMBOL_R_BRACKET> Description()
}



void Description() :
{}
{
(<RESERVED_WORD_DESCRIPTION> <CONST_LITERAL>)?
}


//Tipo Enumerado ðŸ¡ª
void EnumeratedType() :
{}
{
(<RESERVED_WORD_DECLARATION> <RESERVED_WORD_TYPE> <ESP_SYMBOL_L_BRACKET> ListEnumeratedType() <ESP_SYMBOL_R_BRACKET>)?
}

void ListEnumeratedType() :
{}
{
<IDENTIFIER> <RESERVED_WORD_IS> IdConstantsList() <ESP_SYMBOL_DOT> ListEnumeratedTypeL()
}

void ListEnumeratedTypeL()  :
{}
{
(ListEnumeratedType())?
}


//Lista de Identificadores de ConstantesðŸ¡ª
void IdConstantsList() :
{}
{
ConstantsList() IdConstantsListL()
}

void IdConstantsListL() :
{}
{
( <ESP_SYMBOL_COMA> IdConstantsList())?
}

void ConstantsList()  :
{}
{
<CONST_INT> | <CONST_REAL> | <CONST_LITERAL>
}



//Lista de Identificadores de VariÃ¡veisðŸ¡ª
void IdentifiersVariablesList() :
{}
{
VariablesList() IdentifiersVariablesListL()
}

void IdentifiersVariablesListL() :
{}
{
( <ESP_SYMBOL_COMA> IdentifiersVariablesList())?
}

void VariablesList() :
{}
{
(<CONST_INT> | <CONST_REAL> | <CONST_LITERAL>) Index()
}

//Tipo de VariÃ¡veisðŸ¡ª
void TypeVariables() :
{}
{
<RESERVED_WORD_INTEGER> | <RESERVED_WORD_REAL> | <RESERVED_WORD_STRING> | <RESERVED_WORD_LOGIC> | <RESERVED_WORD_ENUM>
}


//Tipo de ConstantesðŸ¡ª
void TypeAndValueConstants() :
{}
{
<RESERVED_WORD_INTEGER> <ESP_SYMBOL_ASSIGNE> <CONST_INT> | <RESERVED_WORD_REAL> <ESP_SYMBOL_ASSIGNE> <CONST_REAL> | <RESERVED_WORD_STRING> <ESP_SYMBOL_ASSIGNE> <CONST_LITERAL> | <RESERVED_WORD_LOGIC> <ESP_SYMBOL_ASSIGNE> TypeAndValueLogicConstants()
}
void TypeAndValueLogicConstants() :
{}
{
<RESERVED_WORD_TRUE> | <RESERVED_WORD_UNTRUE>
}


//Constantes e VariÃ¡veis ðŸ¡ª
void ConstantsAndVariables() :
{}
{
(<RESERVED_WORD_DECLARATION> <RESERVED_WORD_CONSTANT> <RESERVED_WORD_AND> <RESERVED_WORD_VARIABLE> <ESP_SYMBOL_L_BRACKET> OrderConstantsAndVariables() <ESP_SYMBOL_R_BRACKET>)? 
}

void OrderConstantsAndVariables() :
{}
{
<RESERVED_WORD_AS> OrderConstantAndVariable()
}

void OrderConstantAndVariable() :
{}
{
<RESERVED_WORD_CONSTANT> ConstantsDec() (<RESERVED_WORD_AS> <RESERVED_WORD_VARIABLE>  VariablesDec())? | <RESERVED_WORD_VARIABLE>  VariablesDec() (<RESERVED_WORD_AS> <RESERVED_WORD_CONSTANT> ConstantsDec())?
}

void ConstantsDec() :
{}
{
IdConstantsList() <RESERVED_WORD_IS> TypeAndValueConstants() <ESP_SYMBOL_DOT> ConstantsDecL()
}

void ConstantsDecL() :
{}
{
(ConstantsDec())?
}

void VariablesDec() :
{}
{
IdentifiersVariablesList() <RESERVED_WORD_IS>  TypeVariables() <ESP_SYMBOL_DOT> VariablesDecL()
}

void VariablesDecL() :
{}
{
(VariablesDec())?
}

//AtribuiÃ§Ã£o ðŸ¡ª
void Assignment() :
{}
{
<RESERVED_WORD_DESIGNATE> <RESERVED_WORD_THIS> IdentifiersVariablesList() <RESERVED_WORD_AS> Expression() <ESP_SYMBOL_DOT>
}

//Entrada de dados ðŸ¡ª
void DataInput() :
{}
{
<RESERVED_WORD_READ> <RESERVED_WORD_THIS> <ESP_SYMBOL_L_BRACKET>  IdentifiersVariablesList() <ESP_SYMBOL_R_BRACKET> <ESP_SYMBOL_DOT>
}

//SaÃ­da de dados ðŸ¡ª
void DataOutput() :
{}
{
<RESERVED_WORD_WRITE> DataOutputL()
}

void DataOutputL() :
{}
{
(<RESERVED_WORD_ALL>)? DataOutputS()
}

void DataOutputS() :
{}
{
<RESERVED_WORD_THIS> <ESP_SYMBOL_L_BRACKET> IdentifiersAndOrConstantsList() <ESP_SYMBOL_R_BRACKET> <ESP_SYMBOL_DOT> 
}

//Lista de identificadores e/ou constantes ðŸ¡ª
void IdentifiersAndOrConstantsList() :
{}
{
IdConstantsList() IdentifiersAndOrConstantsListL()
}
void IdentifiersAndOrConstantsListL() :
{}
{
(IdentifiersVariablesList())?
}


//SeleÃ§Ã£o ðŸ¡ª
void Selection() :
{}
{
<RESERVED_WORD_AVALIATE> <RESERVED_WORD_THIS> Expression() Avaliation() <ESP_SYMBOL_DOT>
}

void Avaliation() :
{}
{
TrueResult() AvaliationLT() | UntrueResult() AvaliationLU()
}

void AvaliationLT() :
{}
{
(UntrueResult())?
}

void AvaliationLU() :
{}
{
(TrueResult())? 
}

void UntrueResult() :
{}
{
<RESERVED_WORD_UNTRUE> <RESERVED_WORD_RESULT> <ESP_SYMBOL_L_BRACKET> CommandList() <ESP_SYMBOL_R_BRACKET> 
}

void TrueResult() :
{}
{
<RESERVED_WORD_TRUE> <RESERVED_WORD_RESULT> <ESP_SYMBOL_L_BRACKET> CommandList() <ESP_SYMBOL_R_BRACKET> 
}

//Lista de comandos ðŸ¡ª

void CommandList() :
{}
{
Command() (CommandN())? CommandListL()
}

void CommandListL() :
{}
{
(CommandList())?
}

void Command() :
{}
{
Assignment() | DataInput()  | DataOutput() | Selection() | Repetition()
}

void CommandN() :
{}
{
<RESERVED_WORD_DECLARATION> TwoCommands()
}

void TwoCommands() :
{}
{
EnumType() | ConstAndVar()
}

void EnumType() :
{}
{
<RESERVED_WORD_TYPE> <ESP_SYMBOL_L_BRACKET>  ListEnumeratedType() <ESP_SYMBOL_R_BRACKET>
}

void ConstAndVar() :
{}
{
<RESERVED_WORD_CONSTANT> <RESERVED_WORD_AND> <RESERVED_WORD_VARIABLE> <ESP_SYMBOL_L_BRACKET> OrderConstantsAndVariables() <ESP_SYMBOL_R_BRACKET>
}


//RepetiÃ§Ã£o ðŸ¡ª
void Repetition() :
{}
{
<RESERVED_WORD_REPEAT> <RESERVED_WORD_THIS> Expression() <ESP_SYMBOL_L_BRACKET> CommandList() <ESP_SYMBOL_R_BRACKET> <ESP_SYMBOL_DOT>
}
 
//ExpressÃ£o ðŸ¡ª
void Expression() :
{}
{
ArithmeticOrLogicalExpression() ExpressionL()
}

void ExpressionL() :
{}
{
(<ESP_SYMBOL_EQUAL>  ArithmeticOrLogicalExpression() | <ESP_SYMBOL_DIFFERENT> ArithmeticOrLogicalExpression() | <ESP_SYMBOL_GREATER>  ArithmeticOrLogicalExpression() |  <ESP_SYMBOL_LESSER> ArithmeticOrLogicalExpression() | <ESP_SYMBOL_LESSERREQUAL> ArithmeticOrLogicalExpression() | <ESP_SYMBOL_GREATEREQUAL> ArithmeticOrLogicalExpression())?
}

void ArithmeticOrLogicalExpression() :
{}
{
SecondTerm() LowestPriority()
}

void LowestPriority() :
{}
{
(<ESP_SYMBOL_PLUS> SecondTerm() LowestPriority() | <ESP_SYMBOL_MINUS> SecondTerm() LowestPriority() | <ESP_SYMBOL_OR> SecondTerm() LowestPriority())?
}

void SecondTerm() :
{}
{
FirstTerm() MediumPriority() 
}

void MediumPriority () :
{}
{
(<ESP_SYMBOL_STAR> FirstTerm() MediumPriority() | <ESP_SYMBOL_DIVISION_REAL> FirstTerm() MediumPriority() | <ESP_SYMBOL_DIVISION_INT> FirstTerm() MediumPriority() | <ESP_SYMBOL_MOD> FirstTerm() MediumPriority() | <ESP_SYMBOL_AND> FirstTerm() MediumPriority())?
}

void FirstTerm() :
{}
{
Element() HighestPriority()
}

void HighestPriority() :
{}
{
(<ESP_SYMBOL_POWER> Element() HighestPriority())?
}

void Element() :
{}
{
<IDENTIFIER> Index() | <CONST_INT> | <CONST_REAL> | <CONST_LITERAL> | <RESERVED_WORD_TRUE> | <RESERVED_WORD_UNTRUE> | <ESP_SYMBOL_L_PARENTHESIS> Expression() <ESP_SYMBOL_R_PARENTHESIS> | <ESP_SYMBOL_DIFFERENT> <ESP_SYMBOL_L_PARENTHESIS> Expression() <ESP_SYMBOL_R_PARENTHESIS>
}

void Index() :
{}
{
(<ESP_SYMBOL_L_BRACE> <CONST_INT> <ESP_SYMBOL_R_BRACE>)?
}




//lexical analysis
public void parseLexical() : { }
{
    (
        nonsupportedBlockComment()
        | specialSymbol()
        | reservedWord()
        | constInt()
        | constReal()
        | constLiteral()
        | identifier()
        | nonsupportedSymbol()
        | nonsupportedConstLiteralSingle()
        | nonsupportedConstLiteralDouble()
        | nonsupportedIdentifier()
    )*
}

void specialSymbol() : { }
{
    (
        <ESP_SYMBOL_L_BRACKET>  
        | <ESP_SYMBOL_R_BRACKET> 
        | <ESP_SYMBOL_L_PARENTHESIS> 
        | <ESP_SYMBOL_R_PARENTHESIS> 
        | <ESP_SYMBOL_L_BRACE> 
        | <ESP_SYMBOL_R_BRACE> 
        | <ESP_SYMBOL_DOT> 
        | <ESP_SYMBOL_COMA> 
        | <ESP_SYMBOL_ASSIGNE> 
        | <ESP_SYMBOL_PLUS> 
        | <ESP_SYMBOL_MINUS> 
        | <ESP_SYMBOL_STAR> 
        | <ESP_SYMBOL_DIVISION_REAL> 
        | <ESP_SYMBOL_POWER> 
        | <ESP_SYMBOL_DIVISION_INT> 
        | <ESP_SYMBOL_MOD> 
        | <ESP_SYMBOL_EQUAL> 
        | <ESP_SYMBOL_DIFFERENT> 
        | <ESP_SYMBOL_GREATER> 
        | <ESP_SYMBOL_LESSER> 
        | <ESP_SYMBOL_GREATEREQUAL> 
        | <ESP_SYMBOL_LESSERREQUAL> 
        | <ESP_SYMBOL_AND> 
        | <ESP_SYMBOL_OR> 
        | <ESP_SYMBOL_NOT>
    )
    {
        lexicalAnalysis.printRecognizedToken(token.image, "Simbolo Especial", token.kind, token.beginLine, token.beginColumn);
    }
}

void reservedWord() : { }
{
     (
          <RESERVED_WORD_DO>
        | <RESERVED_WORD_THIS>
        | <RESERVED_WORD_BODY>
        | <RESERVED_WORD_DESCRIPTION>
        | <RESERVED_WORD_DECLARATION>
        | <RESERVED_WORD_TYPE>
        | <RESERVED_WORD_IS>
        | <RESERVED_WORD_CONSTANT>
        | <RESERVED_WORD_AND>
        | <RESERVED_WORD_VARIABLE>
        | <RESERVED_WORD_AS>
        | <RESERVED_WORD_INTEGER>
        | <RESERVED_WORD_REAL>
        | <RESERVED_WORD_STRING>
        | <RESERVED_WORD_LOGIC>
        | <RESERVED_WORD_DESIGNATE>
        | <RESERVED_WORD_READ>
        | <RESERVED_WORD_WRITE>
        | <RESERVED_WORD_ALL>
        | <RESERVED_WORD_REPEAT>
        | <RESERVED_WORD_AVALIATE>
        | <RESERVED_WORD_TRUE>
        | <RESERVED_WORD_UNTRUE>
    )
    {
        lexicalAnalysis.printRecognizedToken(token.image, "Palavra Reservada", token.kind, token.beginLine, token.beginColumn);

    }
}


void constInt() : { }
{
    <CONST_INT>
    {
        lexicalAnalysis.printRecognizedToken(token.image, "Constante Inteira", token.kind, token.beginLine, token.beginColumn);

    }
}

void constReal() : { }
{
    <CONST_REAL>
    {
        lexicalAnalysis.printRecognizedToken(token.image, "Constante Real", token.kind, token.beginLine, token.beginColumn);

    }
}

void constLiteral() : { }
{
    <CONST_LITERAL>
    {
        lexicalAnalysis.printRecognizedToken(token.image, "Constante Literal", token.kind, token.beginLine, token.beginColumn);

    }
}

void identifier() : { }
{
    <IDENTIFIER>
    {
        lexicalAnalysis.printRecognizedToken(token.image, "Identificador", token.kind, token.beginLine, token.beginColumn);

    }
}


void nonsupportedSymbol() : { lexErrorCount++; }
{
    <NONSUPPORTED_SYMBOL>
    {
        lexicalAnalysis.printNotRecognizedToken(token.image, "Simbolo nao suportado", token.kind, token.beginLine, token.beginColumn);

    }
}

void nonsupportedConstLiteralSingle() : { lexErrorCount++; }
{
    <NONSUPPORTED_CONST_LITERAL_SINGLE>
    {
        lexicalAnalysis.printNotRecognizedToken(token.image, "Constante literal nao suportada, faltando aspas simples", token.kind, token.beginLine, token.beginColumn);

    }
}

void nonsupportedConstLiteralDouble() : { lexErrorCount++; }
{
    <NONSUPPORTED_CONST_LITERAL_DOUBLE>
    {
        lexicalAnalysis.printNotRecognizedToken(token.image, "Constante literal nao suportada. faltando aspas duplas", token.kind, token.beginLine, token.beginColumn);
;
    }
}

void nonsupportedBlockComment() : { lexErrorCount++; }
{
    <NONSUPPORTED_BLOCK_COMMENT>
    {
        lexicalAnalysis.printNotRecognizedToken(token.image, "Nao contem o fechamento do bloco de comentario", token.kind, token.beginLine, token.beginColumn);

    }
}

void nonsupportedIdentifier() : { lexErrorCount++; }
{
    <NONSUPPORTED_IDENTIFIER>
    {
        lexicalAnalysis.printNotRecognizedToken(token.image, "Identificador invalido", token.kind, token.beginLine, token.beginColumn);

    }
}